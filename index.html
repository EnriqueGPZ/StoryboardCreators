<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Storyboard y Escaleta para Creators - Herramienta Online y Gratuita</title>
  
  <meta name="description" content="Crea storyboards y escaletas profesionales para tus vídeos de YouTube, cursos o proyectos creativos. Herramienta online, gratuita y fácil de usar. Planifica tus secuencias, notas y referencias visuales en un solo lugar.">
  <meta name="keywords" content="storyboard online, creador de storyboard, escaleta, creador de escaleta, escaleta para video, escaleta audiovisual, herramienta para youtubers, planificador de vídeo, guion gráfico, storyboard gratis, video planner, storyboard creator">
  <meta name="author" content="Storyboard for Creators">
  <link rel="canonical" href="https://[TU-URL-AQUI.com]/final.html" />

  <meta property="og:title" content="Storyboard y Escaleta para Creators - Herramienta Online Gratuita" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://[TU-URL-AQUI.com]/final.html" />
  <meta property="og:image" content="https://[URL-A-UNA-IMAGEN-PREVIEW.png]" />
  <meta property="og:description" content="Planifica tus vídeos como un profesional con esta herramienta de storyboard y escaleta online y gratuita. Ideal para creadores de contenido, cineastas y educadores." />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,400,0,0" rel="stylesheet" />
  
  <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "SoftwareApplication",
        "name": "Storyboard y Escaleta para Creators",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Web",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "Una herramienta online y gratuita para crear storyboards y escaletas detalladas, planificar secuencias, añadir notas, referencias visuales y exportar a PDF y ZIP. Diseñada para creadores de contenido, cineastas y educadores.",
        "url": "https://[TU-URL-AQUI.com]/final.html"
      }
    ]
  }
  </script>

  <style>
    :root{
      --bg: #f9f9fb;
      --surface: #ffffff;
      --line: #ebebeb;
      --txt: #1d1d1f;
      --muted: #86868b;
      --acc: #007aff;
      --red: #d70015;
      --orange: #ff9500;
      --green: #34c759;
      --canvas-bg: #f5f5f7;
      --bg-alt: #f5f5f7; 
    }
    body.dark-theme {
      --bg: #1c1c1e;
      --surface: #2c2c2e;
      --line: #3a3a3c;
      --txt: #f2f2f7;
      --muted: #8d8d92;
      --acc: #0a84ff;
      --red: #ff453a;
      --orange: #ff9f0a;
      --green: #30d158;
      --canvas-bg: #1c1c1e;
      --bg-alt: #2c2c2e;
    }

    html { scroll-behavior: smooth; }
    *{box-sizing:border-box}body{margin:0;background:var(--bg);font-family:'Roboto',sans-serif;color:var(--txt);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;transition: background-color .2s, color .2s;}
    .container{max-width:800px;margin:48px auto;padding:0 24px 64px;}
    .btn{appearance:none;border:none;background:transparent;color:var(--txt);padding:0;font-size:13px;font-weight:500;cursor:pointer;line-height:1;display:inline-flex;align-items:center;justify-content:center;transition:background-color .2s,color .2s,border-color .2s;border-radius:0; text-decoration: none;}
    
    .site-header { background: var(--bg-alt); padding: 16px 24px; border-bottom: 1px solid var(--line); }
    .site-header h1 { font-size: 22px; margin: 0; font-weight: 700; display: flex; align-items: center; gap: 12px; }
    .app-icon { height: 30px; width: auto; }

    .hero { text-align: center; padding: 80px 24px; background: var(--bg-alt); }
    .hero-logo { height: 100px; width: auto; margin-bottom: 32px; }
    .hero h2 { font-size: 42px; font-weight: 700; margin: 0 0 16px 0; color: var(--txt); }
    .hero p { font-size: 18px; color: var(--muted); max-width: 600px; margin: 0 auto 32px auto; line-height: 1.6; }
    .hero .btn.primary { font-size: 16px; padding: 12px 24px; border-radius: 8px; background-color: var(--acc); color: #fff; }
    .hero .btn.primary:hover { background-color: #0071e3; }
    
    .features { padding: 60px 24px; background: var(--bg-alt); }
    .features h2 { text-align: center; font-size: 32px; margin: 0 0 48px 0; }
    
    .features-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 30px; max-width: 1000px; margin: 0 auto; }
    @media (max-width: 900px) { .features-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 500px) { .features-grid { grid-template-columns: 1fr; } }
    
    .feature-item { text-align: center; }
    .feature-item .material-symbols-rounded { font-size: 40px; color: var(--acc); margin-bottom: 16px; }
    .feature-item h3 { font-size: 18px; margin: 0 0 8px 0; }
    .feature-item p { font-size: 14px; color: var(--muted); line-height: 1.5; margin: 0; }
    
    .post-app-section { padding: 60px 24px; background: var(--bg-alt); border-top: 1px solid var(--line); }
    .post-app-section h2 { text-align: center; font-size: 32px; margin: 0 0 48px 0; }
    
    .faq-container { max-width: 700px; margin: 0 auto; }
    .faq-container details { background: var(--surface); border: 1px solid var(--line); border-radius: 8px; margin-bottom: 12px; }
    .faq-container summary { font-size: 16px; font-weight: 500; padding: 16px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .faq-container summary::-webkit-details-marker { display: none; }
    .faq-container summary::after { content: '+'; font-size: 24px; color: var(--muted); }
    .faq-container details[open] summary::after { content: '−'; }
    .faq-container .answer { padding: 0 16px 16px 16px; font-size: 14px; color: var(--muted); line-height: 1.6; border-top: 1px solid var(--line); margin-top: 8px; }
    
    .application-wrapper { background: var(--surface); }
    footer.site-footer { text-align: center; padding: 24px; font-size: 12px; color: var(--muted); background: var(--bg-alt); }
    
    .project-section { margin-bottom: 64px; }
    #app header{ display:flex; gap:16px; align-items:center; justify-content:flex-end; flex-wrap:wrap; padding:16px 24px; background:rgba(255,255,255,.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); position:sticky; top:0; z-index:50; border-bottom:1px solid var(--line); }
    body.dark-theme #app header { background: rgba(28, 28, 30, 0.7); }
    #app header .toolbar .btn{width:40px;height:40px;}
    #app header .toolbar .btn .material-symbols-rounded{font-size:22px;}
    #app header .toolbar .btn.primary{background-color:var(--acc);color:#fff;}
    #app header .toolbar .btn.alt{color:var(--muted);}
    #app header .toolbar .btn.red{color:var(--red);}
    
    input[type="text"],textarea{width:100%;background:var(--bg-alt);border:none;border-bottom:1px solid var(--line);color:var(--txt);padding:10px 4px;font-size:14px;border-radius:0;transition:border-color .2s;}
    input[type="text"]:focus,textarea:focus{outline:none;border-bottom-color:var(--acc);}
    textarea{min-height:120px;resize:vertical;}
    label{font-size:13px;color:var(--muted);font-weight:500;display:block;margin-bottom:8px;}
    .scene{background:var(--surface);margin-bottom:32px; border: 1px solid var(--line); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); overflow: hidden;}
    body.dark-theme .scene { box-shadow: none; }
    .scene-hd{display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap;padding:12px 16px;border-bottom:1px solid var(--line);}
    .scene-idx{color:var(--muted);font-size:11px;font-weight:700;letter-spacing:0.5px;}
    .scene-ttl{flex:1;min-width:200px;font-size:16px;font-weight:700;border:none;background:transparent;padding:0; color: var(--txt);}
    .scene-ttl:focus{outline:none;}
    .scene .bd{padding:20px;}
    .scene-hd .toolbar{display:flex; align-items:center; gap: 4px;}
    .scene-hd .btn{width:32px;height:32px;color:var(--muted);}
    .scene-hd .btn:hover{background-color:var(--line);color:var(--txt);}
    .scene-hd .btn.red:hover{background-color:#fff5f5;color:var(--red);}
    body.dark-theme .scene-hd .btn.red:hover{background-color:rgba(255,69,58,0.1);color:var(--red);}
    .scene-hd .material-symbols-rounded{font-size:20px;}
    .tags-container{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
    .chip{font-size:12px;color:var(--muted);background:transparent;border:1px solid var(--line);padding:4px 12px;display:inline-flex;align-items:center;gap:6px;font-weight:500;}
    .remove-tag{cursor:pointer;font-size:16px;line-height:1;font-weight:400;}
    .remove-tag:hover{color:var(--txt);}
    .tabs{display:flex;border-bottom:1px solid var(--line);margin-bottom:20px;}
    .tab{padding:10px 16px;font-size:14px;color:var(--muted);cursor:pointer;border-bottom:2px solid transparent;margin-bottom:-1px;font-weight:500;position:relative;}
    .tab.active{color:var(--txt);border-color:var(--txt);}
    .tab.has-content:not(.active)::after{content:'';display:inline-block;width:6px;height:6px;background-color:var(--acc);border-radius:50%;margin-left:8px;vertical-align:2px;}
    
    .tab-content{display:none;padding-top:8px;}
    .tab-content.active{display:block;}

    .thumbs{display:grid;grid-template-columns:repeat(auto-fill, minmax(120px, 1fr));gap:10px;}
    .thumb{position:relative;background:var(--bg-alt);overflow:hidden;border-radius:4px;}
    .thumb img{display:block;width:100%;aspect-ratio:16/9;object-fit:cover;background-color:var(--bg-alt);}
    .thumb .x{position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.5);color:#fff;font-size:14px;width:20px;height:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:50%;}
    .thumb .x:hover{background:rgba(0,0,0,0.7);}
    .thumb-name-wrapper { padding: 4px 8px 8px; background-color: var(--bg-alt); border-top: 1px solid var(--line); }
    .thumb-name { font-size: 12px; text-align: center; color: var(--muted); padding: 4px; border-radius: 4px; word-break: break-all; cursor: text; transition: background-color .2s, box-shadow .2s; }
    .thumb-name:focus { background-color: var(--surface); outline: none; box-shadow: 0 0 0 2px var(--acc); color: var(--txt); }

    .sketch{border:1px solid var(--line);overflow:hidden;}
    canvas{display:block;width:100%;height:auto;background:var(--canvas-bg);cursor:crosshair;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px;}
    .controls .btn{padding:8px 12px;border:1px solid var(--line);}
    .controls .btn .material-symbols-rounded { font-size: 20px; margin-right: 4px; }
    .controls .btn.red{border:1px solid var(--red);}
    .controls .btn.active{background-color:var(--acc);color:#fff;border-color:var(--acc);}
    body.dark-theme .controls .btn.red{border:1px solid var(--red); color: var(--red);}
    body.dark-theme .controls .btn.red:hover{background-color:rgba(255,69,58,0.1);}
    .color-picker { padding: 0; border: none; width: 28px; height: 28px; cursor: pointer; background: transparent; vertical-align: middle; margin-left: auto; }
    .color-picker::-webkit-color-swatch-wrapper { padding: 0; }
    .color-picker::-webkit-color-swatch { border-radius: 50%; border: 2px solid var(--line); }
    .color-picker::-moz-color-swatch { border-radius: 50%; border: 2px solid var(--line); }

    .grid-layout{display:grid;grid-template-columns:1fr 1fr;gap:24px;align-items:start;}
    @media (max-width: 500px){.grid-layout{grid-template-columns:1fr;}}
    .dialog-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:1000;opacity:0;visibility:hidden;transition:opacity .2s,visibility .2s;}
    .dialog-overlay:not([hidden]){opacity:1;visibility:visible;}
    .dialog-box{background:var(--surface);padding:24px;border-radius:12px;width:90%;max-width:400px;transform:scale(0.95);transition:transform .2s; border: 1px solid var(--line);}
    .dialog-overlay:not([hidden]) .dialog-box{transform:scale(1);}
    .dialog-box h3{margin:0 0 8px 0;font-size:18px;font-weight:700;color:var(--txt);}
    .dialog-box p{margin:0 0 24px 0;font-size:14px;color:var(--muted);line-height:1.5;}
    .dialog-actions{display:flex;justify-content:flex-end;gap:12px;}
    .dialog-actions .btn{padding:8px 16px;border-radius:8px;}
    .dialog-actions .btn.primary{background-color:var(--acc);color:#fff;}
    
    #format-dialog-box .dialog-actions { justify-content: center; }
    #format-dialog-box .btn { flex-grow: 1; }

    .location-wrapper { position: relative; }
    .btn-location-link { position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 36px; height: 36px; color: var(--muted); border-radius: 50%; }
    .btn-location-link:hover { background-color: transparent; color: var(--txt); }
    .btn-location-link .material-symbols-rounded { font-size: 20px; }
    .btn-location-link.has-link { color: var(--acc); }
    .btn-location-link.has-link:hover { color: #0071e3; }

    .status-dot-wrapper { display: flex; align-items: center; border-left: 1px solid var(--line); padding-left: 12px; margin-left: 8px; }
    .status-dot { width: 18px; height: 18px; border-radius: 50%; cursor: pointer; border: 2px solid var(--line); background-color: var(--surface); transition: background-color .2s, border-color .2s; }
    .status-dot.red { background-color: var(--red); border-color: var(--red); }
    .status-dot.orange { background-color: var(--orange); border-color: var(--orange); }
    .status-dot.green { background-color: var(--green); border-color: var(--green); }

    .help-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1010; opacity: 0; visibility: hidden; transition: opacity .2s, visibility .2s; }
    .help-modal-overlay:not([hidden]) { opacity: 1; visibility: visible; }
    .help-modal-box { background: var(--surface); width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto; border-radius: 12px; position: relative; transform: scale(0.95); transition: transform 0.2s; }
    .help-modal-overlay:not([hidden]) .help-modal-box { transform: scale(1); }
    .help-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; border-bottom: 1px solid var(--line); position: sticky; top: 0; background: var(--surface); }
    .help-modal-header h2 { font-size: 20px; margin: 0; }
    .help-modal-close { font-size: 24px; cursor: pointer; color: var(--muted); }
    .help-modal-close:hover { color: var(--txt); }
    .help-modal-content { padding: 0 24px 24px; }
    .help-modal-content h3 { font-size: 22px; margin: 40px 0 16px 0; border-bottom: 1px solid var(--line); padding-bottom: 8px; }
    .help-modal-content h4 { font-size: 16px; margin: 24px 0 8px 0; font-weight: 700; }
    .help-modal-content p, .help-modal-content li { font-size: 14px; color: var(--muted); line-height: 1.7; }
    .help-modal-content ul, .help-modal-content ol { padding-left: 20px; margin-top: 0; }
    .help-modal-content strong { color: var(--txt); font-weight: 500; }
    .help-modal-content code { background: var(--bg-alt); padding: 2px 6px; border-radius: 4px; font-size: 13px; }
  
    .spinner {
        display: inline-block; width: 22px; height: 22px;
        border: 2px solid currentColor; border-right-color: transparent;
        border-radius: 50%; animation: spin .75s linear infinite;
    }
    .btn .spinner { display: none; }
    .btn.loading .spinner { display: inline-block; }
    .btn.loading .material-symbols-rounded { display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <header class="site-header">
    <h1>
      <img src="Logo.png" alt="Logo de Storyboard for Creators" class="app-icon">
      Storyboard for Creators
    </h1>
  </header>

  <main>
    <section class="hero">
      <img src="Logo.png" alt="Logo de Storyboard for Creators" class="hero-logo">
      <h2>Crea Storyboards y Escaletas Profesionales, Fácil y Rápido.</h2>
      <p>La herramienta definitiva para creadores de contenido. Planifica tus vídeos, organiza tus ideas en una escaleta clara y visualiza tu proyecto final, todo en un solo lugar y completamente gratis.</p>
      <a href="#app" class="btn primary">Empezar a Crear Ahora</a>
    </section>

    <section class="features">
      <h2>Características Principales</h2>
      <div class="features-grid">
        <div class="feature-item"><span class="material-symbols-rounded">layers</span><h3>Escaleta Detallada</h3><p>Organiza tu guion en una escaleta de secuencias. Añade notas, localizaciones y detalles de producción para cada escena.</p></div>
        <div class="feature-item"><span class="material-symbols-rounded">palette</span><h3>Dibujo Avanzado</h3><p>Usa herramientas como flechas, rectángulos y un selector de color para crear storyboards más detallados y expresivos.</p></div>
        <div class="feature-item"><span class="material-symbols-rounded">dark_mode</span><h3>Modo Oscuro</h3><p>Trabaja cómodamente en cualquier condición de luz con el nuevo tema oscuro, que cuida tu vista y tu concentración.</p></div>
        <div class="feature-item"><span class="material-symbols-rounded">speed</span><h3>Rendimiento Optimizado</h3><p>Las imágenes se cargan de forma inteligente a medida que las necesitas, garantizando una experiencia fluida incluso en proyectos grandes.</p></div>
      </div>
    </section>

    <section id="app" class="application-wrapper">
      <header>
        <div class="toolbar">
          <button class="btn primary" id="btn-add" title="Añadir nueva secuencia"><span class="material-symbols-rounded">add</span></button>
          <button class="btn alt" id="btn-export-pdf" title="Exportar a PDF"><span class="material-symbols-rounded">picture_as_pdf</span><span class="spinner"></span></button>
          <button class="btn alt" id="btn-export-zip" title="Exportar a ZIP"><span class="material-symbols-rounded">archive</span><span class="spinner"></span></button>
          <label class="btn alt" title="Importar desde ZIP"><span class="material-symbols-rounded">unarchive</span><input id="import-zip" type="file" accept="application/zip" hidden /></label>
          <button class="btn red" id="btn-clear" title="Vaciar proyecto"><span class="material-symbols-rounded">delete_sweep</span></button>
          <button class="btn alt" id="btn-theme-toggle" title="Cambiar tema"><span class="material-symbols-rounded">dark_mode</span></button>
          <button class="btn alt" id="btn-help" title="Ayuda"><span class="material-symbols-rounded">help</span></button>
        </div>
      </header>
      <div class="container">
        <div class="project-section">
          <div style="margin-bottom:24px;"><label for="title">Título del proyecto</label><input type="text" id="title" placeholder="p. ej., Review de la nueva cámara X" style="font-size:24px;font-weight:700;padding:12px 4px"/></div>
          <div class="grid-layout" style="margin-bottom:24px;"><div><label for="author">Autor</label><input type="text" id="author" placeholder="Tu nombre"/></div><div></div></div>
          <div><label for="synopsis">Sinopsis del proyecto</label><textarea id="synopsis" placeholder="Idea principal, público objetivo, tono del vídeo, puntos clave a cubrir..." style="min-height:150px;"></textarea></div>
        </div>
        <div id="scenes"></div>
      </div>
    </section>
    
    <section class="post-app-section">
        <h2>Preguntas Frecuentes</h2>
        <div class="faq-container">
            <details><summary>¿Es esta herramienta realmente gratuita?</summary><div class="answer">Sí, 'Storyboard for Creators' es completamente gratuita. No hay funciones de pago ni suscripciones. Todos los datos se guardan localmente en tu propio navegador.</div></details>
            <details><summary>¿Dónde se guardan mis datos?</summary><div class="answer">Tus proyectos se guardan de forma segura en el almacenamiento de tu navegador (usando IndexedDB). Esto significa que son privados y solo accesibles desde el dispositivo y navegador que utilizas. Nadie más puede verlos.</div></details>
            <details><summary>¿Puedo usar mis proyectos en otro ordenador?</summary><div class="answer">Sí. Puedes usar la función 'Exportar a ZIP' para guardar una copia de seguridad completa de tu proyecto (datos e imágenes) como un archivo <code>.zip</code>. Luego, en otro ordenador, puedes usar 'Importar desde ZIP' para cargar y continuar trabajando en tu proyecto.</div></details>
        </div>
    </section>

    <footer class="site-footer">
      <p>&copy; 2024 Creado por Enrique Gil. Storyboard for Creators es una herramienta de código abierto para la comunidad creativa.</p>
    </footer>
  </main>
  
  <script>
    const db = new Dexie('storyboardAppDB');
    db.version(1).stores({ project: 'id' });

    document.addEventListener('DOMContentLoaded', async () => {
      const $ = (sel, p = document) => p.querySelector(sel);
      const $$ = (sel, p = document) => Array.from(p.querySelectorAll(sel));
      const uid = () => Math.random().toString(36).slice(2);
      
      const themeToggle = $('#btn-theme-toggle');
      const themeIcon = $('span', themeToggle);
      
      const applyTheme = (theme) => {
        const oldDefault = theme === 'dark' ? '#000000' : '#ffffff';
        const newDefault = theme === 'dark' ? '#ffffff' : '#000000';
        
        if (theme === 'dark') {
          document.body.classList.add('dark-theme');
          themeIcon.textContent = 'light_mode';
          themeToggle.title = 'Cambiar a tema claro';
        } else {
          document.body.classList.remove('dark-theme');
          themeIcon.textContent = 'dark_mode';
          themeToggle.title = 'Cambiar a tema oscuro';
        }
        
        $$('.color-picker').forEach(picker => {
          if (picker.value.toLowerCase() === oldDefault) {
            picker.value = newDefault;
          }
        });
      };

      let currentTheme = localStorage.getItem('storyboard-theme') || 'light';
      applyTheme(currentTheme);

      themeToggle.onclick = () => {
        currentTheme = document.body.classList.contains('dark-theme') ? 'light' : 'dark';
        localStorage.setItem('storyboard-theme', currentTheme);
        applyTheme(currentTheme);
      };
      
      const defaultScene = () => ({ id: uid(), title: 'Nueva secuencia', location: '', locationURL: null, description: '', tags: [], sketch: null, refs: [], statusColor: null });
      
      const PROJECT_ID = 1;
      let state = { title: 'Storyboard Project', author: '', synopsis: '', scenes: [defaultScene()] };
      let objectURLs = [];

      const blobToDataURL = (blob) => new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); });
      const getCanvasBlob = (canvas) => new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      const fileToBlob = (file) => new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(new Blob([reader.result], {type: file.type})); reader.onerror = reject; reader.readAsArrayBuffer(file); });

      async function persist() { try { await db.project.put({ id: PROJECT_ID, ...state }); } catch (error) { console.error("Error al guardar en IndexedDB:", error); } }
      async function loadInitialState() { try { const savedState = await db.project.get(PROJECT_ID); if (savedState) { delete savedState.id; Object.assign(state, savedState); state.scenes.forEach(s => { if (!s.tags) s.tags = []; if (!s.refs) s.refs = []; if (!s.locationURL) s.locationURL = null; if (!s.statusColor) s.statusColor = null; }); } } catch (error) { console.error("Error al cargar desde IndexedDB:", error); } }
      function revokeObjectURLs() { objectURLs.forEach(url => URL.revokeObjectURL(url)); objectURLs = []; }

      const lazyLoadObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const el = entry.target;
            
            // This now only applies to the canvas
            const canvas = $('canvas[data-src]', el);
            if (canvas) {
              const url = canvas.dataset.src;
              const ctx = canvas.getContext('2d');
              const image = new Image();
              image.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
              };
              image.src = url;
              canvas.removeAttribute('data-src');
            }
            
            observer.unobserve(el);
          }
        });
      }, { rootMargin: '200px' });

      function render() {
        revokeObjectURLs();
        $('#title').value = state.title;
        $('#author').value = state.author;
        $('#synopsis').value = state.synopsis;
        const wrap = $('#scenes');
        wrap.innerHTML = '';
        state.scenes.forEach((s, i) => {
          const sceneEl = renderScene(s, i);
          wrap.appendChild(sceneEl);
          // Only observe the whole scene element for the canvas lazy loading
          lazyLoadObserver.observe(sceneEl);
        });
      }
      
      function renderScene(scene, index) {
        const el = document.createElement('div');
        el.className = 'scene';
        el.dataset.id = scene.id;
        
        el.innerHTML = `<div class="scene-hd"> <span class="scene-idx">SECUENCIA ${index + 1}</span> <input class="scene-ttl" type="text" value="${escapeHtml(scene.title)}" placeholder="Título de la secuencia"/> <div class="toolbar"> <div class="status-dot-wrapper"> <span class="status-dot" title="Cambiar estado"></span> </div> <button class="btn download-sb" title="Descargar Storyboard"><span class="material-symbols-rounded">image</span></button> <button class="btn up" title="Mover arriba"><span class="material-symbols-rounded">arrow_upward</span></button> <button class="btn down" title="Mover abajo"><span class="material-symbols-rounded">arrow_downward</span></button> <button class="btn dup" title="Duplicar"><span class="material-symbols-rounded">content_copy</span></button> <button class="btn red del" title="Eliminar"><span class="material-symbols-rounded">delete</span></button> </div> </div><div class="bd"> <div class="grid-layout"> <div class="location-wrapper"> <label>Localización</label> <input class="inp-location" type="text" value="${escapeHtml(scene.location)}" placeholder="Estudio, calle, interior…"/> <button class="btn btn-location-link" title="Abrir enlace (Clic) / Editar (Clic derecho)"><span class="material-symbols-rounded">link</span></button> </div> <div> <label>Etiquetas</label> <input class="inp-tags" type="text" placeholder="Añadir etiqueta y pulsar Enter"/> <div class="tags-container"></div> </div> </div> <div class="tabs" style="margin-top:24px;"> <div class="tab active" data-tab="desc">Descripción Escenas</div> <div class="tab" data-tab="refs">Referencias</div> <div class="tab" data-tab="storyboard">Storyboard</div> </div> <div class="tab-content active" data-content="desc"> <textarea class="inp-desc" placeholder="Detalla las escenas de esta secuencia, el corazón de tu escaleta. Describe planos, diálogos, acciones, atrezo, etc.">${escapeHtml(scene.description)}</textarea> </div> <div class="tab-content" data-content="refs"> <div class="toolbar" style="margin-bottom:12px"> <label class="btn" style="padding: 8px 12px; border: 1px solid var(--line);">Subir imágenes <input class="file-refs" type="file" accept="image/*" multiple hidden></label> </div> <div class="thumbs"></div> </div> <div class="tab-content" data-content="storyboard"> <div class="sketch"> <canvas width="1000" height="560"></canvas> </div> <div class="controls"> <button class="btn alt active" data-tool="draw" title="Pincel"><span class="material-symbols-rounded">brush</span></button> <button class="btn alt" data-tool="line" title="Línea"><span class="material-symbols-rounded">horizontal_rule</span></button> <button class="btn alt" data-tool="rectangle" title="Rectángulo"><span class="material-symbols-rounded">crop_square</span></button> <button class="btn alt" data-tool="circle" title="Círculo"><span class="material-symbols-rounded">radio_button_unchecked</span></button> <button class="btn alt" data-tool="arrow" title="Flecha"><span class="material-symbols-rounded">arrow_forward</span></button> <button class="btn alt" data-tool="text" title="Texto"><span class="material-symbols-rounded">title</span></button> <button class="btn alt" data-tool="erase" title="Borrador"><span class="material-symbols-rounded">ink_eraser</span></button> <label style="margin-left: 16px;">Grosor <input class="size" type="range" min="1" max="50" value="3" style="vertical-align: middle;"></label> <input type="color" class="color-picker" title="Seleccionar color"> <button class="btn alt btn-add-to-refs" title="Añadir a Referencias" style="margin-left: 8px;"><span class="material-symbols-rounded">add_photo_alternate</span></button> <button class="btn red clear" style="margin-left: 8px;">Limpiar</button> </div> </div> </div>`;
        
        const updateAndRender = async () => { await persist(); render(); };
        const update = async () => { await persist(); };
        
        $('.scene-ttl', el).addEventListener('input', async e => { scene.title = e.target.value; await update(); });
        $('.inp-location', el).addEventListener('input', async e => { scene.location = e.target.value; await update(); });
        const linkBtn = $('.btn-location-link', el);
        if (scene.locationURL) { linkBtn.classList.add('has-link'); }
        linkBtn.onclick = async () => { if (scene.locationURL) { window.open(scene.locationURL, '_blank', 'noopener,noreferrer'); } else { const url = prompt('Pega la URL para esta localización (p. ej., de Google Maps):', 'https://'); if (url && url.trim() !== 'https://' && url.trim() !== '') { scene.locationURL = url.trim(); await updateAndRender(); } } };
        linkBtn.addEventListener('contextmenu', async (e) => { e.preventDefault(); if (!scene.locationURL) return; const newURL = prompt('Edita o elimina el enlace de la localización:', scene.locationURL); if (newURL === null) { return; } scene.locationURL = newURL.trim() === '' ? null : newURL.trim(); await updateAndRender(); });
        $('.inp-desc', el).addEventListener('input', async e => { scene.description = e.target.value; await update(); });
        $('.up', el).onclick = () => { if (index > 0) { swap(state.scenes, index, index - 1); updateAndRender(); } };
        $('.down', el).onclick = () => { if (index < state.scenes.length - 1) { swap(state.scenes, index, index + 1); updateAndRender(); } };
        $('.dup', el).onclick = () => { const clone = JSON.parse(JSON.stringify(scene)); clone.id = uid(); state.scenes.splice(index + 1, 0, clone); updateAndRender(); };
        $('.del', el).onclick = () => showDialog({ title: 'Eliminar Secuencia', message: '¿Seguro que quieres eliminar esta secuencia? Esta acción no se puede deshacer.', confirmText: 'Sí, eliminar', onConfirm: () => { state.scenes.splice(index, 1); if (!state.scenes.length) state.scenes.push(defaultScene()); updateAndRender(); } });
        
        $('.download-sb', el).onclick = () => {
          if (!scene.sketch) { alert('No hay nada en el storyboard para descargar.'); return; }
          showExportFormatDialog(scene, index);
        };

        const statusDot = $('.status-dot', el);
        const colorCycle = [null, 'red', 'orange', 'green'];
        if (scene.statusColor) { statusDot.classList.add(scene.statusColor); }
        statusDot.onclick = async () => { const currentIndex = colorCycle.indexOf(scene.statusColor); const nextIndex = (currentIndex + 1) % colorCycle.length; scene.statusColor = colorCycle[nextIndex]; await updateAndRender(); };

        const tabs = $$('.tab', el);
        tabs.forEach(tab => { tab.onclick = () => { tabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); $$('.tab-content', el).forEach(c => c.classList.toggle('active', c.dataset.content === tab.dataset.tab)); }; });
        if (scene.refs && scene.refs.length > 0) $('.tab[data-tab="refs"]', el).classList.add('has-content');
        if (scene.sketch) $('.tab[data-tab="storyboard"]', el).classList.add('has-content');
        
        const tagsContainer = $('.tags-container', el);
        const tagsInput = $('.inp-tags', el);
        function drawTags() { tagsContainer.innerHTML = ''; (scene.tags || []).forEach(tag => { const tagEl = document.createElement('span'); tagEl.className = 'chip'; tagEl.innerHTML = `${escapeHtml(tag)} <span class="remove-tag" title="Quitar">&times;</span>`; $('.remove-tag', tagEl).onclick = async () => { scene.tags = scene.tags.filter(t => t !== tag); drawTags(); await update(); }; tagsContainer.appendChild(tagEl); }); }
        tagsInput.addEventListener('keydown', async e => { if (e.key === 'Enter' && tagsInput.value.trim() !== '') { e.preventDefault(); const newTags = tagsInput.value.trim().split(',').map(t => t.trim()).filter(Boolean); scene.tags.push(...newTags); scene.tags = [...new Set(scene.tags)]; drawTags(); await update(); tagsInput.value = ''; } });
        drawTags();
        
        const thumbs = $('.thumbs', el);
        const fileInput = $('.file-refs', el);
        fileInput.onchange = async () => { const files = Array.from(fileInput.files || []); for (const f of files) { const blob = await fileToBlob(f); scene.refs.push({ id: uid(), name: f.name, data: blob }); } await updateAndRender(); fileInput.value = ''; };
        
        function drawThumbs() { 
          thumbs.innerHTML = ''; 
          if (!scene.refs.length) { thumbs.innerHTML = '<div style="color:var(--muted); font-size:12px;">Sube imágenes para verlas aquí.</div>'; return; } 
          scene.refs.forEach(r => { 
            const t = document.createElement('div'); t.className = 'thumb'; 
            t.innerHTML = `<img alt="${escapeHtml(r.name)}"/><div class="thumb-name-wrapper"><p class="thumb-name" contenteditable="true" spellcheck="false" title="Haz clic para editar el nombre">${escapeHtml(r.name)}</p></div><div class="x" title="Quitar imagen">&times;</div>`;
            if (r.data instanceof Blob) { 
              // <-- CAMBIO CLAVE: Carga directa de la imagen
              const url = URL.createObjectURL(r.data); 
              $('img', t).src = url; // Se asigna directamente a SRC, no a data-src
              objectURLs.push(url); 
            }
            $('.x', t).onclick = async () => { scene.refs = scene.refs.filter(x => x.id !== r.id); await updateAndRender(); };
            const nameEl = $('.thumb-name', t);
            nameEl.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); } });
            nameEl.addEventListener('blur', async () => { const newName = nameEl.textContent.trim(); if (newName && r.name !== newName) { r.name = newName; $('img', t).alt = newName; await update(); } else { nameEl.textContent = r.name; } });
            thumbs.appendChild(t); 
          }); 
        }
        drawThumbs();
        
        const canvas = $('canvas', el);
        const ctx = canvas.getContext('2d');
        const controls = $('.controls', el);
        const sizeInput = $('.size', el);
        const colorPicker = $('.color-picker', el);
        colorPicker.value = document.body.classList.contains('dark-theme') ? '#ffffff' : '#000000';
        if (scene.sketch instanceof Blob) {
          const url = URL.createObjectURL(scene.sketch);
          canvas.dataset.src = url; // El canvas sigue usando lazy load, que es seguro
          objectURLs.push(url);
        }
        
        let activeTool = 'draw', isDrawing = false, startPos = null, lastPos = null, savedCanvasState = null;
        const getPos = (e) => getXY(e, canvas);
        
        const drawFinalShape = (start, end) => {
            const color = colorPicker.value;
            const lineWidth = +sizeInput.value;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.globalCompositeOperation = 'source-over';
            
            ctx.beginPath();
            if (activeTool === 'line') {
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
            } else if (activeTool === 'rectangle') {
                ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
            } else if (activeTool === 'circle') {
                const radius = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                ctx.arc(start.x, start.y, radius, 0, Math.PI * 2);
            } else if (activeTool === 'arrow') {
                const headLength = 10 + lineWidth;
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(end.x - headLength * Math.cos(angle - Math.PI / 6), end.y - headLength * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(end.x - headLength * Math.cos(angle + Math.PI / 6), end.y - headLength * Math.sin(angle + Math.PI / 6));
            }
            ctx.stroke();
        };

        const startDrawing = (e) => {
          e.preventDefault(); const posEvent = e.touches ? e.touches[0] : e;
          if (activeTool === 'text') { 
            const text = prompt('Escribe el texto que quieres añadir:', ''); 
            if (text) { 
              const pos = getPos(posEvent); 
              ctx.font = `${+sizeInput.value * 3}px Roboto`; 
              ctx.fillStyle = colorPicker.value;
              ctx.globalCompositeOperation = 'source-over'; 
              ctx.fillText(text, pos.x, pos.y); 
              (async () => { scene.sketch = await getCanvasBlob(canvas); await update(); $('.tab[data-tab="storyboard"]', el).classList.add('has-content'); })(); 
            } 
            return; 
          }
          isDrawing = true; startPos = getPos(posEvent); lastPos = startPos;
          if (['line', 'rectangle', 'circle', 'arrow'].includes(activeTool)) {
            savedCanvasState = ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
        };
        const draw = (e) => {
          if (!isDrawing) return; e.preventDefault(); const posEvent = e.touches ? e.touches[0] : e; const currentPos = getPos(posEvent);
          if (activeTool === 'draw' || activeTool === 'erase') { 
            ctx.lineWidth = +sizeInput.value; 
            ctx.lineCap = 'round'; 
            ctx.strokeStyle = colorPicker.value;
            ctx.globalCompositeOperation = activeTool === 'erase' ? 'destination-out' : 'source-over'; 
            ctx.beginPath(); ctx.moveTo(lastPos.x, lastPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke(); 
            lastPos = currentPos; 
          } else if (savedCanvasState) { 
            ctx.putImageData(savedCanvasState, 0, 0); 
            drawFinalShape(startPos, currentPos); 
          }
        };
        const endDrawing = async (e) => {
            if (!isDrawing) return; e.preventDefault(); const posEvent = e.changedTouches ? e.changedTouches[0] : e;
            if (savedCanvasState) {
                ctx.putImageData(savedCanvasState, 0, 0);
                drawFinalShape(startPos, getPos(posEvent));
            }
            isDrawing = false; savedCanvasState = null; 
            scene.sketch = await getCanvasBlob(canvas); await update(); $('.tab[data-tab="storyboard"]', el).classList.add('has-content');
        };

        canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', endDrawing); canvas.addEventListener('mouseleave', endDrawing);
        canvas.addEventListener('touchstart', startDrawing, { passive: false }); canvas.addEventListener('touchmove', draw, { passive: false }); canvas.addEventListener('touchend', endDrawing); canvas.addEventListener('touchcancel', endDrawing);
        $$('.btn[data-tool]', controls).forEach(btn => { btn.onclick = () => { activeTool = btn.dataset.tool; $$('.btn[data-tool]', controls).forEach(b => b.classList.remove('active')); btn.classList.add('active'); }; });
        $('.clear', controls).onclick = async () => { ctx.clearRect(0, 0, canvas.width, canvas.height); scene.sketch = null; await update(); $('.tab[data-tab="storyboard"]', el).classList.remove('has-content'); };
        
        $('.btn-add-to-refs', el).onclick = async () => {
          if (!scene.sketch) {
            alert('El storyboard está vacío. Dibuja algo antes de añadirlo a las referencias.');
            return;
          }
          const blob = await getCanvasBlob(canvas);
          const newRef = {
            id: uid(),
            name: `Storyboard Shot - ${new Date().toLocaleTimeString()}.png`,
            data: blob
          };
          if (!scene.refs) { scene.refs = []; }
          scene.refs.push(newRef);
          await updateAndRender();
        };
        
        return el;
      }
      
      const dialog = { overlay: $('#custom-dialog-overlay'), title: $('#dialog-title'), message: $('#dialog-message'), btnConfirm: $('#dialog-btn-confirm'), btnCancel: $('#dialog-btn-cancel') };
      let onConfirmCallback = null;
      function showDialog({ title, message, confirmText = 'Continuar', onConfirm }) { dialog.title.textContent = title; dialog.message.textContent = message; dialog.btnConfirm.textContent = confirmText; onConfirmCallback = onConfirm; dialog.overlay.hidden = false; }
      function hideDialog() { dialog.overlay.hidden = true; onConfirmCallback = null; }
      dialog.btnConfirm.onclick = () => { if (typeof onConfirmCallback === 'function') { onConfirmCallback(); } hideDialog(); };
      dialog.btnCancel.onclick = hideDialog;
      dialog.overlay.onclick = (e) => { if (e.target === dialog.overlay) hideDialog(); };

      const formatDialog = { overlay: $('#format-dialog-overlay'), btnPng: $('#format-btn-png'), btnJpg: $('#format-btn-jpg') };
      function showExportFormatDialog(scene, index) {
        formatDialog.overlay.hidden = false;
        const exportAndHide = (format) => {
          exportStoryboardImage(scene, index, format);
          formatDialog.overlay.hidden = true;
        };
        formatDialog.btnPng.onclick = () => exportAndHide('png');
        formatDialog.btnJpg.onclick = () => exportAndHide('jpeg');
        formatDialog.overlay.onclick = (e) => { if(e.target === formatDialog.overlay) formatDialog.overlay.hidden = true; };
      }
      
      async function exportStoryboardImage(scene, index, format = 'png') {
        if (!(scene.sketch instanceof Blob)) return;
        const mimeType = `image/${format}`;
        const extension = format;
        const quality = 0.9;
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const img = new Image();

        img.onload = () => {
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          
          const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
          tempCtx.fillStyle = bgColor;
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
          tempCtx.drawImage(img, 0, 0);

          tempCanvas.toBlob(blob => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `storyboard-${slug(scene.title || `secuencia-${index+1}`)}.${extension}`;
            a.click();
            URL.revokeObjectURL(a.href);
          }, mimeType, quality);

          URL.revokeObjectURL(img.src);
        };
        img.src = URL.createObjectURL(scene.sketch);
      }

      const helpModal = { overlay: $('#help-modal-overlay'), btnOpen: $('#btn-help'), btnClose: $('#help-modal-close') };
      helpModal.btnOpen.onclick = () => { helpModal.overlay.hidden = false; };
      helpModal.btnClose.onclick = () => { helpModal.overlay.hidden = true; };
      helpModal.overlay.onclick = (e) => { if (e.target === helpModal.overlay) helpModal.overlay.hidden = true; };
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !helpModal.overlay.hidden) { helpModal.overlay.hidden = true; } });
      
      $('#title').addEventListener('input', async e => { state.title = e.target.value; await persist(); });
      $('#author').addEventListener('input', async e => { state.author = e.target.value; await persist(); });
      $('#synopsis').addEventListener('input', async e => { state.synopsis = e.target.value; await persist(); });
      $('#btn-add').onclick = async () => { state.scenes.push(defaultScene()); await persist(); render(); };
      $('#btn-clear').onclick = () => showDialog({ title: 'Vaciar Proyecto', message: '¿Estás seguro de que quieres borrar todo el proyecto? Esta acción es irreversible.', confirmText: 'Sí, vaciar', onConfirm: async () => { state.title = 'Mi Nuevo Proyecto'; state.author = ''; state.synopsis = ''; state.scenes = [defaultScene()]; await persist(); render(); } });
      
      const pdfWorkerScript = `
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');

        self.onmessage = async (e) => {
            try {
                const { state } = e.data;
                const { jsPDF } = self.jspdf;
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });

                const MARGIN = 40;
                const PAGE_W = doc.internal.pageSize.getWidth();
                const CONTENT_W = PAGE_W - MARGIN * 2;
                const slug = (s = '') => s.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^a-z0-9\\s-]/g, '').replace(/[\\s-]+/g, '-').replace(/(^-|-$)/g, '');

                doc.setFont('helvetica', 'bold');
                doc.setFontSize(24);
                doc.text(state.title || 'Proyecto de Storyboard', PAGE_W / 2, MARGIN + 20, { align: 'center' });

                if (state.author) {
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(14);
                    doc.text(\`Por: \${state.author}\`, PAGE_W / 2, MARGIN + 50, { align: 'center' });
                }
                
                if (state.synopsis) {
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(12);
                    doc.text('Sinopsis', MARGIN, MARGIN + 90);
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(10);
                    const synopsisLines = doc.splitTextToSize(state.synopsis, CONTENT_W);
                    doc.text(synopsisLines, MARGIN, MARGIN + 110);
                }

                for (let i = 0; i < state.scenes.length; i++) {
                    const scene = state.scenes[i];
                    doc.addPage();
                    let y = MARGIN;

                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(16);
                    doc.text(\`SECUENCIA \${i + 1}: \${scene.title || 'Sin título'}\`, MARGIN, y);
                    y += 30;

                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(9);
                    doc.setTextColor(100);
                    if (scene.location) { doc.text(\`Localización: \${scene.location}\`, MARGIN, y); y += 15; }
                    if (scene.tags && scene.tags.length > 0) { doc.text(\`Etiquetas: \${scene.tags.join(', ')}\`, MARGIN, y); y += 15; }
                    y += 10;
                    
                    if (scene.description) {
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.setTextColor(0);
                        doc.text('Descripción', MARGIN, y);
                        y += 20;
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(10);
                        const descLines = doc.splitTextToSize(scene.description, CONTENT_W);
                        doc.text(descLines, MARGIN, y);
                        y += (descLines.length * 12) + 20;
                    }

                    if (scene.sketch && typeof scene.sketch === 'string') {
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.setTextColor(0);
                        doc.text('Storyboard', MARGIN, y);
                        y += 20;
                        const imgHeight = CONTENT_W * 9 / 16;
                        try {
                            doc.addImage(scene.sketch, undefined, MARGIN, y, CONTENT_W, imgHeight);
                            y += imgHeight + 20;
                        } catch (err) {
                            doc.text('Error: No se pudo añadir la imagen del storyboard.', MARGIN, y);
                            y += 20;
                        }
                    }

                    const refs = scene.refs.filter(r => r.data && typeof r.data === 'string');
                    if (refs.length > 0) {
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.setTextColor(0);
                        doc.text('Referencias', MARGIN, y);
                        y += 20;
                        const imgWidth = (CONTENT_W / 2) - 5;
                        const imgHeight = imgWidth * 9 / 16;
                        for (let j = 0; j < refs.length; j++) {
                            const x = MARGIN + (j % 2) * (imgWidth + 10);
                            try {
                                doc.addImage(refs[j].data, undefined, x, y, imgWidth, imgHeight);
                            } catch(err) {
                                doc.text('Error img.', x, y);
                            }
                            if (j % 2 !== 0 || j === refs.length - 1) {
                                y += imgHeight + 10;
                            }
                        }
                    }
                }

                const pdfBlob = doc.output('blob');
                self.postMessage({ blob: pdfBlob, filename: \`\${slug(state.title || 'proyecto')}.pdf\` });

            } catch (error) {
                self.postMessage({ error: error.message + ' Stack: ' + error.stack });
            }
        };
      `;
      
      const zipWorkerScript = `
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
        self.onmessage = async (e) => {
          const { state } = e.data;
          const slug = (s = '') => s.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^a-z0-9\\s-]/g, '').replace(/[\\s-]+/g, '-').replace(/(^-|-$)/g, '');
          
          const zip = new JSZip();
          const assetsFolder = zip.folder("assets");
          const stateForJson = JSON.parse(JSON.stringify(state));

          for (let i = 0; i < state.scenes.length; i++) {
              const sceneWithBlobs = state.scenes[i];
              const sceneForJson = stateForJson.scenes[i];

              if (sceneWithBlobs.sketch instanceof Blob) {
                  const filename = \`sketch-\${sceneWithBlobs.id}.png\`;
                  assetsFolder.file(filename, sceneWithBlobs.sketch);
                  sceneForJson.sketch = \`assets/\${filename}\`;
              }
              if (sceneWithBlobs.refs && sceneWithBlobs.refs.length) {
                  for (let j = 0; j < sceneWithBlobs.refs.length; j++) {
                      const refWithBlob = sceneWithBlobs.refs[j];
                      if (refWithBlob.data instanceof Blob) {
                          const extension = refWithBlob.data.type.split('/')[1] || 'png';
                          const filename = \`ref-\${sceneWithBlobs.id}-\${refWithBlob.id}.\${extension}\`;
                          assetsFolder.file(filename, refWithBlob.data);
                          stateForJson.scenes[i].refs[j].data = \`assets/\${filename}\`;
                      }
                  }
              }
          }
          
          zip.file("project.json", JSON.stringify(stateForJson, null, 2));
          const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 9 } });
          self.postMessage({ blob: zipBlob, filename: \`\${slug(state.title || 'proyecto')}.zip\` });
        };
      `;
      
      function createWorker(scriptContent) { 
          const blob = new Blob([scriptContent], { type: 'application/javascript' }); 
          return new Worker(URL.createObjectURL(blob)); 
      }

      async function handleExportWithWorker(button, workerScript) {
        if (button.classList.contains('loading')) return;
        button.classList.add('loading');
        button.disabled = true;

        const stateFromDB = await db.project.get(PROJECT_ID);
        if (!stateFromDB) {
            alert("No hay proyecto guardado para exportar.");
            button.classList.remove('loading');
            button.disabled = false;
            return;
        }
        
        const worker = createWorker(workerScript);

        worker.onmessage = (e) => {
            if (e.data.error) {
                console.error('Error desde el Web Worker:', e.data.error);
                alert('Ocurrió un error al generar el archivo. Revisa la consola para más detalles.');
            } else {
                const { blob, filename } = e.data;
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                a.click();
                URL.revokeObjectURL(a.href);
            }
            button.classList.remove('loading');
            button.disabled = false;
            worker.terminate();
        };

        worker.onerror = (e) => {
            console.error('Error fatal en el Web Worker:', e.message, e);
            alert('Ocurrió un error al generar el archivo. Revisa la consola para más detalles.');
            button.classList.remove('loading');
            button.disabled = false;
            worker.terminate();
        };
        
        const stateToExport = stateFromDB;

        if (workerScript === pdfWorkerScript) {
            const stateForExport = JSON.parse(JSON.stringify(stateToExport));
            const conversionPromises = [];

            for (let i = 0; i < stateToExport.scenes.length; i++) {
                const originalScene = stateToExport.scenes[i];
                if (originalScene.sketch instanceof Blob) {
                    conversionPromises.push(
                        blobToDataURL(originalScene.sketch).then(dataUrl => { stateForExport.scenes[i].sketch = dataUrl; })
                    );
                }
                if (originalScene.refs) {
                    for (let j = 0; j < originalScene.refs.length; j++) {
                        const originalRef = originalScene.refs[j];
                        if (originalRef.data instanceof Blob) {
                            conversionPromises.push(
                                blobToDataURL(originalRef.data).then(dataUrl => { stateForExport.scenes[i].refs[j].data = dataUrl; })
                            );
                        }
                    }
                }
            }
            await Promise.all(conversionPromises);
            worker.postMessage({ state: stateForExport });
        } else {
            worker.postMessage({ state: stateToExport });
        }
      }

      $('#btn-export-zip').onclick = () => handleExportWithWorker($('#btn-export-zip'), zipWorkerScript);
      $('#btn-export-pdf').onclick = () => handleExportWithWorker($('#btn-export-pdf'), pdfWorkerScript);

      $('#import-zip').onchange = (e) => {
        const file = e.target.files?.[0]; if (!file) return;
        showDialog({ title: 'Importar Proyecto desde ZIP', message: 'Esto reemplazará tu proyecto actual. ¿Estás seguro?', confirmText: 'Sí, importar',
            onConfirm: async () => {
                try {
                    const zip = await JSZip.loadAsync(file);
                    const projectFile = zip.file("project.json");
                    if (!projectFile) throw new Error("El archivo project.json no se encontró en el ZIP.");
                    const jsonText = await projectFile.async("string"); const data = JSON.parse(jsonText);
                    const loadingPromises = [];
                    for (const scene of data.scenes) {
                        if (typeof scene.sketch === 'string' && scene.sketch.startsWith('assets/')) {
                            const sketchFile = zip.file(scene.sketch);
                            if(sketchFile) loadingPromises.push(sketchFile.async("blob").then(blob => { scene.sketch = blob; }));
                        }
                        if (scene.refs) {
                            for (const ref of scene.refs) {
                                if (typeof ref.data === 'string' && ref.data.startsWith('assets/')) {
                                    const refFile = zip.file(ref.data);
                                    if(refFile) loadingPromises.push(refFile.async("blob").then(blob => { ref.data = blob; }));
                                }
                            }
                        }
                    }
                    await Promise.all(loadingPromises);
                    state = data;
                    state.scenes.forEach(s => { if (!s.tags) s.tags = []; if (!s.refs) s.refs = []; if (!s.locationURL) s.locationURL = null; if (!s.statusColor) s.statusColor = null; });
                    await persist(); render();
                } catch (err) { alert('Error al importar el archivo ZIP.\n\n' + err.message); } 
                finally { e.target.value = ''; }
            }
        });
      };
      
      function swap(arr, i, j) { const t = arr[i]; arr[i] = arr[j]; arr[j] = t; }
      function escapeHtml(s = '') { return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])); }
      function slug(s = '') { return s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9\s-]/g, '').replace(/[\s-]+/g, '-').replace(/(^-|-$)/g, ''); }
      function getXY(e, canvas) { const r = canvas.getBoundingClientRect(); const scaleX = canvas.width / r.width; const scaleY = canvas.height / r.height; return { x: (e.clientX - r.left) * scaleX, y: (e.clientY - r.top) * scaleY }; }
      
      await loadInitialState();
      render();
    });
  </script>

  <!-- Modales -->
  <div id="custom-dialog-overlay" class="dialog-overlay" hidden>
    <div class="dialog-box">
      <h3 id="dialog-title"></h3>
      <p id="dialog-message"></p>
      <div class="dialog-actions">
        <button id="dialog-btn-cancel" class="btn alt">Cancelar</button>
        <button id="dialog-btn-confirm" class="btn primary">Continuar</button>
      </div>
    </div>
  </div>

  <div id="format-dialog-overlay" class="dialog-overlay" hidden>
    <div id="format-dialog-box" class="dialog-box">
      <h3>Seleccionar Formato</h3>
      <p>Elige el formato en el que quieres descargar la imagen del storyboard.</p>
      <div class="dialog-actions">
        <button id="format-btn-png" class="btn alt">PNG (Alta Calidad)</button>
        <button id="format-btn-jpg" class="btn primary">JPEG (Archivo Pequeño)</button>
      </div>
    </div>
  </div>

  <div id="help-modal-overlay" class="help-modal-overlay" hidden>
    <div class="help-modal-box">
      <div class="help-modal-header">
        <h2>Guía Completa de Uso</h2>
        <span class="material-symbols-rounded help-modal-close" id="help-modal-close" title="Cerrar">&times;</span>
      </div>
      <div class="help-modal-content">
        <h3>Trabajando con Secuencias</h3>
        <p>Cada tarjeta representa una secuencia en tu escaleta. En la cabecera de cada una, ahora tienes un nuevo botón para <strong>descargar la imagen del storyboard</strong> de esa secuencia.</p>

        <h4>Pestañas de Contenido</h4>
        <p>La pestaña de <strong>Storyboard</strong> ahora es mucho más potente:</p>
        <ol>
          <li><strong>Nuevas Herramientas:</strong> Además del pincel, línea, círculo y texto, ahora puedes dibujar <strong>rectángulos</strong> y <strong>flechas</strong>.</li>
          <li><strong>Selector de Color:</strong> A la derecha de la barra de herramientas del lienzo, encontrarás un círculo de color. Haz clic en él para elegir cualquier color para tus herramientas de dibujo.</li>
          <li><strong>Exportación Individual:</strong> Al descargar un storyboard, podrás elegir entre <strong>PNG</strong> (calidad máxima) o <strong>JPEG</strong> (tamaño reducido). La imagen se exportará con el fondo del tema que estés usando.</li>
          <li><strong>Tema Inteligente:</strong> El color de dibujo por defecto se ajustará automáticamente si cambias entre el modo claro y oscuro, pero respetará cualquier color personalizado que hayas elegido.</li>
        </ol>
      </div>
    </div>
  </div>

</body>
</html>
