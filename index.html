<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Escaleta Creator - Crea Escaletas y Storyboards Online en escaletas.es</title>
  
  <meta name="description" content="Crea tu escaleta y storyboard profesional con Escaleta Creator. La herramienta online y gratuita para planificar tus vídeos, guiones y proyectos creativos. Organiza secuencias, notas y referencias visuales fácilmente.">
  <meta name="keywords" content="escaleta, creador de escaleta, escaleta para video, escaleta audiovisual, storyboard online, creador de storyboard, Escaleta Creator, herramienta para youtubers, planificador de vídeo, guion gráfico, storyboard gratis, video planner, storyboard creator, escaletas.es">
  <meta name="author" content="Enrique Gil">
  <link rel="canonical" href="https://www.escaletas.es/" />

  <meta property="og:title" content="Escaleta Creator - Herramienta de Escaleta y Storyboard Online" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.escaletas.es/" />
  <meta property="og:image" content="https://www.escaletas.es/og-image.png" />
  <meta property="og:description" content="Planifica tus vídeos como un profesional. Crea escaletas detalladas y storyboards visuales con esta herramienta online y gratuita para creadores de contenido." />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,400,0,0" rel="stylesheet" />
  
  <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- DEPENDENCIAS PARA EXPORTACIÓN PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "SoftwareApplication",
        "name": "Escaleta Creator",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Web",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "Una herramienta online para crear escaletas audiovisuales y storyboards detallados. Planifica secuencias, añade notas, referencias visuales y exporta a PDF y ZIP. Diseñada para creadores de contenido, cineastas y educadores.",
        "url": "https://www.escaletas.es/"
      }
    ]
  }
  </script>

  <style>
    :root{
      --bg: #f9f9fb;
      --surface: #ffffff;
      --line: #ebebeb;
      --txt: #1d1d1f;
      --muted: #86868b;
      --acc: #007aff;
      --red: #d70015;
      --orange: #ff9500;
      --green: #34c759;
      --canvas-bg: #f5f5f7;
      --bg-alt: #f5f5f7; 
    }
    body.dark-theme {
      --bg: #1c1c1e;
      --surface: #2c2c2e;
      --line: #3a3a3c;
      --txt: #f2f2f7;
      --muted: #8d8d92;
      --acc: #0a84ff;
      --red: #ff453a;
      --orange: #ff9f0a;
      --green: #30d158;
      --canvas-bg: #1c1c1e;
      --bg-alt: #2c2c2e;
    }

    html { scroll-behavior: smooth; }
    *{box-sizing:border-box}body{margin:0;background:var(--bg);font-family:'Roboto',sans-serif;color:var(--txt);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;transition: background-color .2s, color .2s;}
    .container{max-width:800px;margin:48px auto;padding:0 24px 64px;}
    .btn{appearance:none;border:none;background:transparent;color:var(--txt);padding:0;font-size:13px;font-weight:500;cursor:pointer;line-height:1;display:inline-flex;align-items:center;justify-content:center;transition:background-color .2s,color .2s,border-color .2s;border-radius:0; text-decoration: none;}
    
    .site-header { background: var(--bg-alt); padding: 16px 24px; border-bottom: 1px solid var(--line); }
    .site-header h1 { font-size: 22px; margin: 0; font-weight: 700; display: flex; align-items: center; gap: 12px; }
    .app-icon { height: 30px; width: auto; }

    .hero { text-align: center; padding: 80px 24px; background: var(--bg-alt); }
    .hero-logo { height: 100px; width: auto; margin-bottom: 32px; }
    .hero h2 { font-size: 42px; font-weight: 700; margin: 0 0 16px 0; color: var(--txt); }
    .hero p { font-size: 18px; color: var(--muted); max-width: 600px; margin: 0 auto 32px auto; line-height: 1.6; }
    .hero .btn.primary { font-size: 16px; padding: 12px 24px; border-radius: 8px; background-color: var(--acc); color: #fff; }
    .hero .btn.primary:hover { background-color: #0071e3; }
    
    .features { padding: 60px 24px; background: var(--bg-alt); }
    .features h2 { text-align: center; font-size: 32px; margin: 0 0 48px 0; }
    
    .features-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 30px; max-width: 1000px; margin: 0 auto; }
    @media (max-width: 900px) { .features-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 500px) { .features-grid { grid-template-columns: 1fr; } }
    
    .feature-item { text-align: center; }
    .feature-item .material-symbols-rounded { font-size: 40px; color: var(--acc); margin-bottom: 16px; }
    .feature-item h3 { font-size: 18px; margin: 0 0 8px 0; }
    .feature-item p { font-size: 14px; color: var(--muted); line-height: 1.5; margin: 0; }
    
    .post-app-section { padding: 60px 24px; background: var(--bg-alt); border-top: 1px solid var(--line); }
    .post-app-section h2 { text-align: center; font-size: 32px; margin: 0 0 48px 0; }
    
    .faq-container { max-width: 700px; margin: 0 auto; }
    .faq-container details { background: var(--surface); border: 1px solid var(--line); border-radius: 8px; margin-bottom: 12px; }
    .faq-container summary { font-size: 16px; font-weight: 500; padding: 16px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .faq-container summary::-webkit-details-marker { display: none; }
    .faq-container summary::after { content: '+'; font-size: 24px; color: var(--muted); }
    .faq-container details[open] summary::after { content: '−'; }
    .faq-container .answer { padding: 0 16px 16px 16px; font-size: 14px; color: var(--muted); line-height: 1.6; border-top: 1px solid var(--line); margin-top: 8px; }
    
    .application-wrapper { background: var(--surface); }
    footer.site-footer { text-align: center; padding: 24px; font-size: 12px; color: var(--muted); background: var(--bg-alt); }
    
    .project-section { margin-bottom: 64px; }
    #app header{ display:flex; gap:16px; align-items:center; justify-content:flex-end; flex-wrap:wrap; padding:16px 24px; background:rgba(255,255,255,.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); position:sticky; top:0; z-index:50; border-bottom:1px solid var(--line); }
    body.dark-theme #app header { background: rgba(28, 28, 30, 0.7); }
    #app header .toolbar .btn{width:40px;height:40px;}
    #app header .toolbar .btn .material-symbols-rounded{font-size:22px;}
    #app header .toolbar .btn.primary{background-color:var(--acc);color:#fff;}
    #app header .toolbar .btn.alt{color:var(--muted);}
    #app header .toolbar .btn.red{color:var(--red);}
    
    input[type="text"],textarea{width:100%;background:var(--bg-alt);border:none;border-bottom:1px solid var(--line);color:var(--txt);padding:10px 4px;font-size:14px;border-radius:0;transition:border-color .2s;}
    input[type="text"]:focus,textarea:focus{outline:none;border-bottom-color:var(--acc);}
    textarea{min-height:120px;resize:vertical;}
    label{font-size:13px;color:var(--muted);font-weight:500;display:block;margin-bottom:8px;}
    .scene{background:var(--surface);margin-bottom:32px; border: 1px solid var(--line); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); overflow: hidden;}
    body.dark-theme .scene { box-shadow: none; }
    .scene-hd{display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap;padding:12px 16px;border-bottom:1px solid var(--line);}
    .scene-idx{color:var(--muted);font-size:11px;font-weight:700;letter-spacing:0.5px;}
    .scene-ttl{flex:1;min-width:200px;font-size:16px;font-weight:700;border:none;background:transparent;padding:0; color: var(--txt);}
    .scene-ttl:focus{outline:none;}
    .scene .bd{padding:20px;}
    .scene-hd .toolbar{display:flex; align-items:center; gap: 4px;}
    .scene-hd .btn{width:32px;height:32px;color:var(--muted);}
    .scene-hd .btn:hover{background-color:var(--line);color:var(--txt);}
    .scene-hd .btn.red:hover{background-color:#fff5f5;color:var(--red);}
    body.dark-theme .scene-hd .btn.red:hover{background-color:rgba(255,69,58,0.1);color:var(--red);}
    .scene-hd .material-symbols-rounded{font-size:20px;}
    .tags-container{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
    .chip{font-size:12px;color:var(--muted);background:transparent;border:1px solid var(--line);padding:4px 12px;display:inline-flex;align-items:center;gap:6px;font-weight:500;}
    .remove-tag{cursor:pointer;font-size:16px;line-height:1;font-weight:400;}
    .remove-tag:hover{color:var(--txt);}
    .tabs{display:flex;border-bottom:1px solid var(--line);margin-bottom:20px;}
    .tab{padding:10px 16px;font-size:14px;color:var(--muted);cursor:pointer;border-bottom:2px solid transparent;margin-bottom:-1px;font-weight:500;position:relative;}
    .tab.active{color:var(--txt);border-color:var(--txt);}
    .tab.has-content:not(.active)::after{content:'';display:inline-block;width:6px;height:6px;background-color:var(--acc);border-radius:50%;margin-left:8px;vertical-align:2px;}
    
    .tab-content{display:none;padding-top:8px;}
    .tab-content.active{display:block;}

    .thumbs{display:grid;grid-template-columns:repeat(auto-fill, minmax(120px, 1fr));gap:10px;}
    .thumb{position:relative;background:var(--bg-alt);overflow:hidden;border-radius:4px;}
    .thumb img{display:block;width:100%;aspect-ratio:16/9;object-fit:cover;background-color:var(--bg-alt);}
    .thumb .x{position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.5);color:#fff;font-size:14px;width:20px;height:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:50%;}
    .thumb .x:hover{background:rgba(0,0,0,0.7);}
    .thumb .load-on-canvas { position:absolute; bottom:4px; left:4px; background:rgba(0,0,0,0.5); color:#fff; font-size:14px; width:20px; height:20px; display:flex; align-items:center; justify-content:center; cursor:pointer; border-radius:50%; }
    .thumb .load-on-canvas:hover { background:rgba(0,0,0,0.7); }

    .thumb-name-wrapper { padding: 4px 8px 8px; background-color: var(--bg-alt); border-top: 1px solid var(--line); }
    .thumb-name { font-size: 12px; text-align: center; color: var(--muted); padding: 4px; border-radius: 4px; word-break: break-all; cursor: text; transition: background-color .2s, box-shadow .2s; }
    .thumb-name:focus { background-color: var(--surface); outline: none; box-shadow: 0 0 0 2px var(--acc); color: var(--txt); }

    .sketch{border:1px solid var(--line);overflow:hidden;}
    canvas{display:block;width:100%;height:auto;background:var(--canvas-bg);cursor:crosshair;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px;}
    .controls .btn{padding:8px 12px;border:1px solid var(--line);}
    .controls .btn .material-symbols-rounded { font-size: 20px; margin-right: 4px; }
    .controls .btn.red{border:1px solid var(--red);}
    .controls .btn.active{background-color:var(--acc);color:#fff;border-color:var(--acc);}
    body.dark-theme .controls .btn.red{border:1px solid var(--red); color: var(--red);}
    body.dark-theme .controls .btn.red:hover{background-color:rgba(255,69,58,0.1);}
    .color-picker { padding: 0; border: none; width: 28px; height: 28px; cursor: pointer; background: transparent; vertical-align: middle; margin-left: auto; }
    .color-picker::-webkit-color-swatch-wrapper { padding: 0; }
    .color-picker::-webkit-color-swatch { border-radius: 50%; border: 2px solid var(--line); }
    .color-picker::-moz-color-swatch { border-radius: 50%; border: 2px solid var(--line); }

    .grid-layout{display:grid;grid-template-columns:1fr 1fr;gap:24px;align-items:start;}
    @media (max-width: 500px){.grid-layout{grid-template-columns:1fr;}}
    .dialog-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:1000;opacity:0;visibility:hidden;transition:opacity .2s,visibility .2s;}
    .dialog-overlay:not([hidden]){opacity:1;visibility:visible;}
    .dialog-box{background:var(--surface);padding:24px;border-radius:12px;width:90%;max-width:400px;transform:scale(0.95);transition:transform .2s; border: 1px solid var(--line);}
    .dialog-overlay:not([hidden]) .dialog-box{transform:scale(1);}
    .dialog-box h3{margin:0 0 8px 0;font-size:18px;font-weight:700;color:var(--txt);}
    .dialog-box p{margin:0 0 24px 0;font-size:14px;color:var(--muted);line-height:1.5;}
    .dialog-actions{display:flex;justify-content:flex-end;gap:12px;}
    .dialog-actions .btn{padding:8px 16px;border-radius:8px;}
    .dialog-actions .btn.primary{background-color:var(--acc);color:#fff;}
    
    #format-dialog-box .dialog-actions { justify-content: center; }
    #format-dialog-box .btn { flex-grow: 1; }

    .location-wrapper { position: relative; }
    .btn-location-link { position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 36px; height: 36px; color: var(--muted); border-radius: 50%; }
    .btn-location-link:hover { background-color: transparent; color: var(--txt); }
    .btn-location-link .material-symbols-rounded { font-size: 20px; }
    .btn-location-link.has-link { color: var(--acc); }
    .btn-location-link.has-link:hover { color: #0071e3; }

    .status-dot-wrapper { display: flex; align-items: center; border-left: 1px solid var(--line); padding-left: 12px; margin-left: 8px; }
    .status-dot { width: 18px; height: 18px; border-radius: 50%; cursor: pointer; border: 2px solid var(--line); background-color: var(--surface); transition: background-color .2s, border-color .2s; }
    .status-dot.red { background-color: var(--red); border-color: var(--red); }
    .status-dot.orange { background-color: var(--orange); border-color: var(--orange); }
    .status-dot.green { background-color: var(--green); border-color: var(--green); }

    .help-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1010; opacity: 0; visibility: hidden; transition: opacity .2s, visibility .2s; }
    .help-modal-overlay:not([hidden]) { opacity: 1; visibility: visible; }
    .help-modal-box { background: var(--surface); width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto; border-radius: 12px; position: relative; transform: scale(0.95); transition: transform 0.2s; }
    .help-modal-overlay:not([hidden]) .help-modal-box { transform: scale(1); }
    .help-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; border-bottom: 1px solid var(--line); position: sticky; top: 0; background: var(--surface); }
    .help-modal-header h2 { font-size: 20px; margin: 0; }
    .help-modal-close { font-size: 24px; cursor: pointer; color: var(--muted); }
    .help-modal-close:hover { color: var(--txt); }
    .help-modal-content { padding: 0 24px 24px; }
    .help-modal-content h3 { font-size: 22px; margin: 40px 0 16px 0; border-bottom: 1px solid var(--line); padding-bottom: 8px; }
    .help-modal-content h4 { font-size: 16px; margin: 24px 0 8px 0; font-weight: 700; }
    .help-modal-content p, .help-modal-content li { font-size: 14px; color: var(--muted); line-height: 1.7; }
    .help-modal-content ul, .help-modal-content ol { padding-left: 20px; margin-top: 0; }
    .help-modal-content strong { color: var(--txt); font-weight: 500; }
    .help-modal-content code { background: var(--bg-alt); padding: 2px 6px; border-radius: 4px; font-size: 13px; }
  
    .spinner {
        display: inline-block; width: 22px; height: 22px;
        border: 2px solid currentColor; border-right-color: transparent;
        border-radius: 50%; animation: spin .75s linear infinite;
    }
    .btn .spinner { display: none; }
    .btn.loading .spinner { display: inline-block; }
    .btn.loading .material-symbols-rounded, .btn.loading .btn-text { display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <header class="site-header">
    <h1>
      <!-- Logo can be an SVG or an actual image file -->
      <svg class="app-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" stroke="currentColor" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20h60v60H20z"/><path d="M40 40h20v20H40zM30 50h10M60 50h10M50 30v10M50 60v10"/></svg>
      Escaleta Creator
    </h1>
  </header>

  <main>
    <section class="hero">
        <svg style="width: 120px; height: auto; margin-bottom: 32px; color: var(--acc);" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 4h8v4H8V4zm0 6h8v4H8v-4zm0 6h8v4H8v-4z"/></svg>
      <h2>Crea Escaletas y Storyboards Profesionales, Fácil y Rápido.</h2>
      <p>La herramienta definitiva para creadores. Planifica tus vídeos con una escaleta clara, organiza tus ideas y visualiza tu proyecto final, todo en un solo lugar y completamente gratis.</p>
      <a href="#app" class="btn primary">Empezar a Crear Ahora</a>
    </section>

    <section class="features">
      <h2>Características Principales</h2>
      <div class="features-grid">
        <div class="feature-item">
            <span class="material-symbols-rounded">layers</span>
            <h3>Escaleta Detallada</h3>
            <p>Organiza tu guion en secuencias. Añade títulos, descripciones, localizaciones, etiquetas de estado y notas de producción para tener cada escena bajo control.</p>
        </div>
        <div class="feature-item">
            <span class="material-symbols-rounded">palette</span>
            <h3>Storyboard Integrado</h3>
            <p>Visualiza tus planos directamente en cada secuencia. Utiliza herramientas de dibujo como pincel, formas, flechas y texto para crear guiones gráficos claros y efectivos.</p>
        </div>
        <div class="feature-item">
            <span class="material-symbols-rounded">picture_as_pdf</span>
            <h3>Exportación Profesional</h3>
            <p>Genera un documento PDF o un archivo ZIP de tu proyecto. El PDF incluye toda la escaleta y storyboards, ideal para compartir. El ZIP es una copia de seguridad completa.</p>
        </div>
        <div class="feature-item">
            <span class="material-symbols-rounded">lock</span>
            <h3>100% Privado y Local</h3>
            <p>Tu trabajo se guarda de forma segura solo en tu navegador. No se envía nada a la nube, garantizando tu privacidad. Trabaja con tranquilidad, incluso sin conexión a internet.</p>
        </div>
      </div>
    </section>

    <section id="app" class="application-wrapper">
      <header>
        <div class="toolbar">
          <button class="btn primary" id="btn-add" title="Añadir nueva secuencia"><span class="material-symbols-rounded">add</span></button>
          <button class="btn alt" id="btn-export-pdf" title="Exportar a PDF"><span class="material-symbols-rounded">picture_as_pdf</span><span class="spinner"></span></button>
          <button class="btn alt" id="btn-export-zip" title="Exportar a ZIP"><span class="material-symbols-rounded">archive</span><span class="spinner"></span></button>
          <label class="btn alt" title="Importar desde ZIP"><span class="material-symbols-rounded">unarchive</span><input id="import-zip" type="file" accept="application/zip" hidden /></label>
          <button class="btn red" id="btn-clear" title="Vaciar proyecto"><span class="material-symbols-rounded">delete_sweep</span></button>
          <button class="btn alt" id="btn-theme-toggle" title="Cambiar tema"><span class="material-symbols-rounded">dark_mode</span></button>
          <button class="btn alt" id="btn-help" title="Ayuda"><span class="material-symbols-rounded">help</span></button>
        </div>
      </header>
      <div class="container">
        <div class="project-section">
          <div style="margin-bottom:24px;"><label for="title">Título del proyecto</label><input type="text" id="title" placeholder="p. ej., Mi nuevo cortometraje" style="font-size:24px;font-weight:700;padding:12px 4px"/></div>
          <div class="grid-layout" style="margin-bottom:24px;"><div><label for="author">Autor</label><input type="text" id="author" placeholder="Tu nombre"/></div><div></div></div>
          <div><label for="synopsis">Sinopsis del proyecto</label><textarea id="synopsis" placeholder="Idea principal, público objetivo, tono del vídeo, puntos clave a cubrir..." style="min-height:150px;"></textarea></div>
        </div>
        <div id="scenes"></div>
      </div>
    </section>
    
    <section class="post-app-section">
        <h2>Preguntas Frecuentes</h2>
        <div class="faq-container">
            <details><summary>¿Es esta herramienta realmente gratuita?</summary><div class="answer">Sí, 'Escaleta Creator' es completamente gratuita. No hay funciones de pago ni suscripciones. Todos los datos se guardan localmente en tu propio navegador.</div></details>
            <details><summary>¿Dónde se guardan mis datos?</summary><div class="answer">Tus proyectos se guardan de forma segura en el almacenamiento de tu navegador (usando IndexedDB). Esto significa que son privados y solo accesibles desde el dispositivo y navegador que utilizas. Nadie más puede verlos.</div></details>
            <details><summary>¿Puedo usar mis proyectos en otro ordenador?</summary><div class="answer">Sí. Puedes usar la función 'Exportar a ZIP' para guardar una copia de seguridad completa de tu proyecto (datos e imágenes) como un archivo <code>.zip</code>. Luego, en otro ordenador, puedes usar 'Importar desde ZIP' para cargar y continuar trabajando en tu proyecto.</div></details>
        </div>
    </section>

    <footer class="site-footer">
      <p>&copy; 2024 Creado por Enrique Gil. Escaleta Creator es una herramienta de código abierto para la comunidad creativa.</p>
    </footer>
  </main>
  
  <script>
    // ====== MAIN APP SCRIPT V4.0.1 (Refactored by PROGRAMADOR with PDF Export) ======

    document.addEventListener('DOMContentLoaded', () => {

        // --- UTILITIES ---
        const $ = (sel, p = document) => p.querySelector(sel);
        const $$ = (sel, p = document) => Array.from(p.querySelectorAll(sel));
        const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2);
        const escapeHtml = (s = '') => String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
        const slug = (s = '') => (s || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9\s-]/g, '').replace(/[\s-]+/g, '-').replace(/(^-|-$)/g, '');
        const swap = (arr, i, j) => { const t = arr[i]; arr[i] = arr[j]; arr[j] = t; };
        const getXY = (e, canvas) => { const r = canvas.getBoundingClientRect(); const scaleX = canvas.width / r.width; const scaleY = canvas.height / r.height; return { x: (e.clientX - r.left) * scaleX, y: (e.clientY - r.top) * scaleY }; };
        const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => func.apply(this, args), delay); }; };

        // --- DATABASE & STATE MANAGEMENT ---
        const db = new Dexie('storyboardAppDB');
        db.version(1).stores({ project: 'id' });
        const PROJECT_ID = 1;
        const defaultScene = () => ({ id: uid(), title: 'Nueva secuencia', location: '', locationURL: null, description: '', tags: [], sketch: null, refs: [], statusColor: null });
        let state = { title: 'Proyecto de Escaleta', author: '', synopsis: '', scenes: [] };
        const sceneNodeCache = new Map(); // Cache: scene.id -> HTMLElement
        const objectURLCache = new Map(); // Cache: Blob -> ObjectURL
        
        const debouncedPersist = debounce(() => persist(), 400);

        async function persist() {
            try {
                await db.project.put({ id: PROJECT_ID, ...state });
            } catch (error) {
                console.error("Error al guardar en IndexedDB:", error);
            }
        }

        // --- CORE LOGIC ---
        function render() {
            $('#title').value = state.title;
            $('#author').value = state.author;
            $('#synopsis').value = state.synopsis;
            const scenesContainer = $('#scenes');
            const existingNodeIds = new Set(Array.from(scenesContainer.children).map(node => node.dataset.id));
            const stateSceneIds = new Set(state.scenes.map(s => s.id));
            let lastNode = null;
            state.scenes.forEach((scene, index) => {
                let sceneEl = sceneNodeCache.get(scene.id);
                if (!sceneEl) {
                    sceneEl = createSceneElement(scene, index);
                    sceneNodeCache.set(scene.id, sceneEl);
                } else {
                    $('.scene-idx', sceneEl).textContent = `SECUENCIA ${index + 1}`;
                    updateSceneUI(sceneEl, scene);
                }
                const expectedPosition = lastNode ? lastNode.nextSibling : scenesContainer.firstChild;
                if (sceneEl !== expectedPosition) {
                    scenesContainer.insertBefore(sceneEl, expectedPosition);
                }
                lastNode = sceneEl;
            });
            existingNodeIds.forEach(id => {
                if (!stateSceneIds.has(id)) {
                    const nodeToRemove = sceneNodeCache.get(id);
                    if (nodeToRemove) {
                        scenesContainer.removeChild(nodeToRemove);
                        sceneNodeCache.delete(id);
                    }
                }
            });
            cleanupObjectURLCache();
        }
        
        function createSceneElement(scene, index) {
            const el = document.createElement('div');
            el.className = 'scene';
            el.dataset.id = scene.id;
            el.innerHTML = `<div class="scene-hd"> <span class="scene-idx">SECUENCIA ${index + 1}</span> <input class="scene-ttl" type="text" value="${escapeHtml(scene.title)}" placeholder="Título de la secuencia"/> <div class="toolbar"> <div class="status-dot-wrapper"> <span class="status-dot" title="Cambiar estado"></span> </div> <button class="btn download-sb" title="Descargar Storyboard"><span class="material-symbols-rounded">image</span></button> <button class="btn up" title="Mover arriba"><span class="material-symbols-rounded">arrow_upward</span></button> <button class="btn down" title="Mover abajo"><span class="material-symbols-rounded">arrow_downward</span></button> <button class="btn dup" title="Duplicar"><span class="material-symbols-rounded">content_copy</span></button> <button class="btn red del" title="Eliminar"><span class="material-symbols-rounded">delete</span></button> </div> </div><div class="bd"> <div class="grid-layout"> <div class="location-wrapper"> <label>Localización</label> <input class="inp-location" type="text" value="${escapeHtml(scene.location)}" placeholder="Estudio, calle, interior…"/> <button class="btn btn-location-link" title="Abrir enlace (Clic) / Editar (Clic derecho)"><span class="material-symbols-rounded">link</span></button> </div> <div> <label>Etiquetas</label> <input class="inp-tags" type="text" placeholder="Añadir etiqueta y pulsar Enter"/> <div class="tags-container"></div> </div> </div> <div class="tabs" style="margin-top:24px;"> <div class="tab active" data-tab="desc">Descripción Escenas</div> <div class="tab" data-tab="refs">Referencias</div> <div class="tab" data-tab="storyboard">Storyboard</div> </div> <div class="tab-content active" data-content="desc"> <textarea class="inp-desc" placeholder="Detalla las escenas de esta secuencia...">${escapeHtml(scene.description)}</textarea> </div> <div class="tab-content" data-content="refs"> <div class="toolbar" style="margin-bottom:12px"> <label class="btn" style="padding: 8px 12px; border: 1px solid var(--line);">Subir imágenes <input class="file-refs" type="file" accept="image/jpeg,image/png" multiple hidden></label> </div> <div class="thumbs"></div> </div> <div class="tab-content" data-content="storyboard"> <div class="sketch"> <canvas width="1000" height="560"></canvas> </div> <div class="controls"> <button class="btn alt active" data-tool="draw" title="Pincel"><span class="material-symbols-rounded">brush</span></button> <button class="btn alt" data-tool="line" title="Línea"><span class="material-symbols-rounded">horizontal_rule</span></button> <button class="btn alt" data-tool="rectangle" title="Rectángulo"><span class="material-symbols-rounded">crop_square</span></button> <button class="btn alt" data-tool="circle" title="Círculo"><span class="material-symbols-rounded">radio_button_unchecked</span></button> <button class="btn alt" data-tool="arrow" title="Flecha"><span class="material-symbols-rounded">arrow_forward</span></button> <button class="btn alt" data-tool="text" title="Texto"><span class="material-symbols-rounded">title</span></button> <button class="btn alt" data-tool="erase" title="Borrador"><span class="material-symbols-rounded">ink_eraser</span></button> <label style="margin-left: 16px;">Grosor <input class="size" type="range" min="1" max="50" value="3" style="vertical-align: middle;"></label> <input type="color" class="color-picker" title="Seleccionar color"> <button class="btn alt btn-add-to-refs" title="Añadir a Referencias" style="margin-left: 8px;"><span class="material-symbols-rounded">add_photo_alternate</span></button> <button class="btn red clear" style="margin-left: 8px;">Limpiar</button> </div> </div> </div>`;
            initializeSceneInputs(el, scene);
            initializeSceneTabs(el, scene);
            initializeSceneRefs(el, scene);
            initializeCanvas(el, scene);
            updateSceneUI(el, scene);
            return el;
        }

        function updateSceneUI(el, scene) {
            const tagsContainer = $('.tags-container', el);
            tagsContainer.innerHTML = '';
            (scene.tags || []).forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'chip';
                tagEl.innerHTML = `${escapeHtml(tag)} <span class="remove-tag" data-tag="${escapeHtml(tag)}" title="Quitar">&times;</span>`;
                tagsContainer.appendChild(tagEl);
            });
            const linkBtn = $('.btn-location-link', el);
            linkBtn.classList.toggle('has-link', !!scene.locationURL);
            const statusDot = $('.status-dot', el);
            statusDot.className = 'status-dot';
            if(scene.statusColor) statusDot.classList.add(scene.statusColor);
            $('.tab[data-tab="refs"]', el).classList.toggle('has-content', scene.refs && scene.refs.length > 0);
            $('.tab[data-tab="storyboard"]', el).classList.toggle('has-content', !!scene.sketch);
            drawThumbs(el, scene);
        }
        
        function initializeSceneInputs(el, scene) {
            $('.scene-ttl', el).addEventListener('input', e => { scene.title = e.target.value; debouncedPersist(); });
            $('.inp-location', el).addEventListener('input', e => { scene.location = e.target.value; debouncedPersist(); });
            $('.inp-desc', el).addEventListener('input', e => { scene.description = e.target.value; debouncedPersist(); });
            $('.inp-tags', el).addEventListener('keydown', e => {
                if (e.key === 'Enter' && e.target.value.trim() !== '') {
                    e.preventDefault();
                    const newTags = e.target.value.trim().split(',').map(t => t.trim()).filter(Boolean);
                    scene.tags = [...new Set([...(scene.tags || []), ...newTags])];
                    e.target.value = '';
                    updateSceneUI(el, scene);
                    persist();
                }
            });
        }

        function initializeSceneTabs(el) {
            const tabs = $$('.tab', el);
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    $$('.tab-content', el).forEach(c => c.classList.toggle('active', c.dataset.content === tab.dataset.tab));
                });
            });
        }

        function initializeSceneRefs(el, scene) {
            $('.file-refs', el).addEventListener('change', async (e) => {
                const files = Array.from(e.target.files || []);
                for (const f of files) {
                    const optimizedBlob = await resizeImageBeforeSave(await fileToBlob(f));
                    if (!scene.refs) scene.refs = [];
                    scene.refs.push({ id: uid(), name: f.name, data: optimizedBlob });
                }
                e.target.value = '';
                updateSceneUI(el, scene);
                await persist();
            });
        }

        function initializeCanvas(el, scene) {
            const canvas = $('canvas', el);
            const ctx = canvas.getContext('2d');
            const controls = $('.controls', el);
            const sizeInput = $('.size', el);
            const colorPicker = $('.color-picker', el);
            colorPicker.value = document.body.classList.contains('dark-theme') ? '#ffffff' : '#000000';
            if (scene.sketch instanceof Blob) drawBlobToCanvas(scene.sketch, canvas);
            let activeTool = 'draw', isDrawing = false, startPos = null, lastPos = null, savedCanvasState = null;
            const startDrawing = (e) => {
                e.preventDefault(); const posEvent = e.touches ? e.touches[0] : e;
                if (activeTool === 'text') {
                    const text = prompt('Escribe el texto:', '');
                    if (text) {
                        const pos = getXY(posEvent, canvas);
                        ctx.font = `${+sizeInput.value * 3}px Roboto`;
                        ctx.fillStyle = colorPicker.value;
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillText(text, pos.x, pos.y);
                        saveCanvasState();
                    }
                    return;
                }
                isDrawing = true; startPos = getXY(posEvent, canvas); lastPos = startPos;
                if (['line', 'rectangle', 'circle', 'arrow'].includes(activeTool)) {
                    savedCanvasState = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
            };
            const draw = (e) => {
                if (!isDrawing) return;
                e.preventDefault(); const posEvent = e.touches ? e.touches[0] : e;
                const currentPos = getXY(posEvent, canvas);
                if (activeTool === 'draw' || activeTool === 'erase') {
                    ctx.lineWidth = +sizeInput.value; ctx.lineCap = 'round'; ctx.strokeStyle = colorPicker.value;
                    ctx.globalCompositeOperation = activeTool === 'erase' ? 'destination-out' : 'source-over';
                    ctx.beginPath(); ctx.moveTo(lastPos.x, lastPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
                    lastPos = currentPos;
                } else if (savedCanvasState) {
                    ctx.putImageData(savedCanvasState, 0, 0);
                    drawFinalShape(ctx, startPos, currentPos, colorPicker.value, +sizeInput.value, activeTool);
                }
            };
            const endDrawing = (e) => {
                if (!isDrawing) return;
                e.preventDefault(); const posEvent = e.changedTouches ? e.changedTouches[0] : e;
                if (savedCanvasState) {
                    ctx.putImageData(savedCanvasState, 0, 0);
                    drawFinalShape(ctx, startPos, getXY(posEvent, canvas), colorPicker.value, +sizeInput.value, activeTool);
                }
                isDrawing = false; savedCanvasState = null;
                saveCanvasState();
            };
            const saveCanvasState = async () => {
                scene.sketch = await getCanvasBlob(canvas);
                $('.tab[data-tab="storyboard"]', el).classList.add('has-content');
                await persist();
            };
            canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', endDrawing); canvas.addEventListener('mouseleave', endDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false }); canvas.addEventListener('touchmove', draw, { passive: false }); canvas.addEventListener('touchend', endDrawing); canvas.addEventListener('touchcancel', endDrawing);
            $$('.btn[data-tool]', controls).forEach(btn => btn.onclick = () => { activeTool = btn.dataset.tool; $$('.btn[data-tool]', controls).forEach(b => b.classList.remove('active')); btn.classList.add('active'); });
            $('.clear', controls).onclick = async () => { ctx.clearRect(0, 0, canvas.width, canvas.height); scene.sketch = null; $('.tab[data-tab="storyboard"]', el).classList.remove('has-content'); await persist(); };
            $('.btn-add-to-refs', el).onclick = async () => {
                if (!scene.sketch) return alert('El storyboard está vacío.');
                const blob = await getCanvasBlob(canvas);
                const newRef = { id: uid(), name: `Storyboard Shot - ${new Date().toLocaleTimeString()}.png`, data: blob };
                if (!scene.refs) scene.refs = [];
                scene.refs.push(newRef);
                updateSceneUI(el, scene);
                await persist();
            };
        }
        
        function setupEventListeners() {
            const scenesContainer = $('#scenes');
            scenesContainer.addEventListener('click', async e => {
                const sceneEl = e.target.closest('.scene');
                if (!sceneEl) return;
                const sceneId = sceneEl.dataset.id;
                const scene = state.scenes.find(s => s.id === sceneId);
                if (!scene) return;
                const sceneIndex = state.scenes.indexOf(scene);
                if (e.target.closest('.del')) {
                    showDialog({ title: 'Eliminar Secuencia', message: '¿Seguro que quieres eliminar esta secuencia?', confirmText: 'Sí, eliminar', onConfirm: async () => { state.scenes.splice(sceneIndex, 1); if (!state.scenes.length) state.scenes.push(defaultScene()); await persist(); render(); } });
                } else if (e.target.closest('.up')) {
                    if (sceneIndex > 0) { swap(state.scenes, sceneIndex, sceneIndex - 1); await persist(); render(); }
                } else if (e.target.closest('.down')) {
                    if (sceneIndex < state.scenes.length - 1) { swap(state.scenes, sceneIndex, sceneIndex + 1); await persist(); render(); }
                } else if (e.target.closest('.dup')) {
                    const clone = await duplicateScene(scene);
                    state.scenes.splice(sceneIndex + 1, 0, clone);
                    await persist(); render();
                } else if (e.target.closest('.download-sb')) {
                    if (scene.sketch) showExportFormatDialog(scene, sceneIndex); else alert('No hay nada en el storyboard para descargar.');
                } else if (e.target.closest('.status-dot')) {
                    const colorCycle = [null, 'red', 'orange', 'green'];
                    const currentIndex = colorCycle.indexOf(scene.statusColor);
                    scene.statusColor = colorCycle[(currentIndex + 1) % colorCycle.length];
                    updateSceneUI(sceneEl, scene);
                    await persist();
                } else if (e.target.closest('.remove-tag')) {
                    const tagToRemove = e.target.dataset.tag;
                    scene.tags = (scene.tags || []).filter(t => t !== tagToRemove);
                    updateSceneUI(sceneEl, scene);
                    await persist();
                } else if (e.target.closest('.btn-location-link')) {
                    if (scene.locationURL) {
                        window.open(scene.locationURL, '_blank', 'noopener,noreferrer');
                    } else {
                        const url = prompt('Pega la URL para esta localización:', 'https://');
                        if (url && url.trim() !== 'https://' && url.trim() !== '') {
                            scene.locationURL = url.trim();
                            updateSceneUI(sceneEl, scene);
                            await persist();
                        }
                    }
                } else if (e.target.closest('.thumb .x')) {
                    const refId = e.target.closest('.thumb').dataset.refId;
                    scene.refs = scene.refs.filter(r => r.id !== refId);
                    updateSceneUI(sceneEl, scene);
                    await persist();
                } else if (e.target.closest('.load-on-canvas')) {
                    if (scene.sketch && !confirm('Esto reemplazará el storyboard actual. ¿Continuar?')) return;
                    const refId = e.target.closest('.thumb').dataset.refId;
                    const ref = scene.refs.find(r => r.id === refId);
                    if (ref) loadImageOntoCanvas($('canvas', sceneEl), ref.data, scene);
                }
            });
            scenesContainer.addEventListener('contextmenu', async e => {
                const linkBtn = e.target.closest('.btn-location-link');
                if (linkBtn) {
                    e.preventDefault();
                    const sceneEl = e.target.closest('.scene');
                    const scene = state.scenes.find(s => s.id === sceneEl.dataset.id);
                    if (scene && scene.locationURL) {
                        const newURL = prompt('Edita o elimina el enlace:', scene.locationURL);
                        if (newURL === null) return;
                        scene.locationURL = newURL.trim() === '' ? null : newURL.trim();
                        updateSceneUI(sceneEl, scene);
                        await persist();
                    }
                }
            });
            scenesContainer.addEventListener('blur', async e => {
                if (e.target.classList.contains('thumb-name')) {
                    const refId = e.target.closest('.thumb').dataset.refId;
                    const sceneEl = e.target.closest('.scene');
                    const scene = state.scenes.find(s => s.id === sceneEl.dataset.id);
                    const ref = scene.refs.find(r => r.id === refId);
                    const newName = e.target.textContent.trim();
                    if (ref && newName && ref.name !== newName) { ref.name = newName; await persist(); }
                    else if (ref) { e.target.textContent = ref.name; }
                }
            }, true);
            scenesContainer.addEventListener('keydown', e => {
                if (e.target.classList.contains('thumb-name') && e.key === 'Enter') { e.preventDefault(); e.target.blur(); }
            });
            $('#btn-add').onclick = async () => { state.scenes.push(defaultScene()); await persist(); render(); };
            $('#btn-clear').onclick = () => showDialog({ title: 'Vaciar Proyecto', message: '¿Seguro que quieres borrar todo el proyecto? Es irreversible.', confirmText: 'Sí, vaciar', onConfirm: async () => { state = { title: 'Proyecto de Escaleta', author: '', synopsis: '', scenes: [defaultScene()] }; await persist(); render(); } });
            $('#title').addEventListener('input', e => { state.title = e.target.value; debouncedPersist(); });
            $('#author').addEventListener('input', e => { state.author = e.target.value; debouncedPersist(); });
            $('#synopsis').addEventListener('input', e => { state.synopsis = e.target.value; debouncedPersist(); });
        }

        // --- HELPER & UTILITY FUNCTIONS ---
        function getURLForBlob(blob) { if (!blob) return ''; if (objectURLCache.has(blob)) { return objectURLCache.get(blob); } const url = URL.createObjectURL(blob); objectURLCache.set(blob, url); return url; }
        const getCanvasBlob = (canvas) => new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        const fileToBlob = (file) => new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(new Blob([reader.result], {type: file.type})); reader.onerror = reject; reader.readAsArrayBuffer(file); });
        function safeClone(obj) { if (typeof structuredClone === 'function') { try { return structuredClone(obj); } catch(e) {} } return JSON.parse(JSON.stringify(obj)); }
        
        function drawThumbs(el, scene) {
            const thumbs = $('.thumbs', el);
            thumbs.innerHTML = '';
            if (!scene.refs || !scene.refs.length) { thumbs.innerHTML = '<div style="color:var(--muted); font-size:12px;">Sube imágenes para verlas aquí.</div>'; return; }
            scene.refs.forEach(r => {
                const t = document.createElement('div');
                t.className = 'thumb'; t.dataset.refId = r.id;
                t.innerHTML = `<img alt="${escapeHtml(r.name)}"/> <div class="thumb-name-wrapper"><p class="thumb-name" contenteditable="true" spellcheck="false" title="Haz clic para editar">${escapeHtml(r.name)}</p></div> <div class="x" title="Quitar imagen">&times;</div> <div class="load-on-canvas" title="Cargar en Storyboard"><span class="material-symbols-rounded">edit_document</span></div>`;
                if (r.data instanceof Blob) { $('img', t).src = getURLForBlob(r.data); }
                thumbs.appendChild(t);
            });
        }

        function drawFinalShape(ctx, start, end, color, lineWidth, tool) {
            ctx.lineWidth = lineWidth; ctx.lineCap = 'round'; ctx.strokeStyle = color; ctx.fillStyle = color; ctx.globalCompositeOperation = 'source-over';
            ctx.beginPath();
            if (tool === 'line') { ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); }
            else if (tool === 'rectangle') { ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y); }
            else if (tool === 'circle') { const radius = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); ctx.arc(start.x, start.y, radius, 0, 2 * Math.PI); }
            else if (tool === 'arrow') { const head = 10 + lineWidth; const angle = Math.atan2(end.y - start.y, end.x - start.x); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.moveTo(end.x, end.y); ctx.lineTo(end.x - head * Math.cos(angle - Math.PI / 6), end.y - head * Math.sin(angle - Math.PI / 6)); ctx.moveTo(end.x, end.y); ctx.lineTo(end.x - head * Math.cos(angle + Math.PI / 6), end.y - head * Math.sin(angle + Math.PI / 6)); }
            ctx.stroke();
        }
        
        async function loadImageOntoCanvas(canvas, imageBlob, scene) {
            drawImageToFit(canvas.getContext('2d'), await createImageBitmap(imageBlob));
            scene.sketch = await getCanvasBlob(canvas);
            await persist();
            const sceneEl = canvas.closest('.scene');
            if (sceneEl) $('.tab[data-tab="storyboard"]', sceneEl).classList.add('has-content');
        }

        function drawImageToFit(ctx, img) {
            const canvas = ctx.canvas; const hRatio = canvas.width / img.width; const vRatio = canvas.height / img.height;
            const ratio = Math.min(hRatio, vRatio); const centerShift_x = (canvas.width - img.width * ratio) / 2; const centerShift_y = (canvas.height - img.height * ratio) / 2;
            const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, img.width, img.height, centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
        }
        
        function drawBlobToCanvas(blob, canvas) {
            const url = getURLForBlob(blob);
            const image = new Image();
            image.onload = () => { canvas.getContext('2d').drawImage(image, 0, 0, canvas.width, canvas.height); };
            image.src = url;
        }

        async function duplicateScene(scene) {
            const clone = safeClone(scene);
            if (scene.sketch instanceof Blob) { clone.sketch = new Blob([scene.sketch], { type: scene.sketch.type }); }
            if (scene.refs) { clone.refs = scene.refs.map(r => { const newRef = { ...r }; if (r.data instanceof Blob) { newRef.data = new Blob([r.data], { type: r.data.type }); } return newRef; }); }
            clone.id = uid();
            return clone;
        }
        
        // --- DIALOGS, EXPORTING, THEME, etc. ---
        const dialog = { overlay: $('#custom-dialog-overlay'), title: $('#dialog-title'), message: $('#dialog-message'), btnConfirm: $('#dialog-btn-confirm'), btnCancel: $('#dialog-btn-cancel') };
        let onConfirmCallback = null;
        function showDialog({ title, message, confirmText = 'Continuar', onConfirm }) { dialog.title.textContent = title; dialog.message.textContent = message; dialog.btnConfirm.textContent = confirmText; onConfirmCallback = onConfirm; dialog.overlay.hidden = false; }
        function hideDialog() { dialog.overlay.hidden = true; onConfirmCallback = null; }
        dialog.btnConfirm.onclick = () => { if (typeof onConfirmCallback === 'function') onConfirmCallback(); hideDialog(); };
        dialog.btnCancel.onclick = hideDialog;
        dialog.overlay.onclick = e => { if (e.target === dialog.overlay) hideDialog(); };
        
        const formatDialog = { overlay: $('#format-dialog-overlay'), btnPng: $('#format-btn-png'), btnJpg: $('#format-btn-jpg') };
        function showExportFormatDialog(scene, index) {
            formatDialog.overlay.hidden = false;
            const exportAndHide = (format) => { exportStoryboardImage(scene, index, format); formatDialog.overlay.hidden = true; };
            formatDialog.btnPng.onclick = () => exportAndHide('png');
            formatDialog.btnJpg.onclick = () => exportAndHide('jpeg');
            formatDialog.overlay.onclick = (e) => { if(e.target === formatDialog.overlay) formatDialog.overlay.hidden = true; };
        }
        
        async function exportStoryboardImage(scene, index, format = 'png') {
            if (!(scene.sketch instanceof Blob)) return;
            const mimeType = `image/${format}`; const extension = format; const quality = 0.9;
            const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d'); const img = new Image();
            img.onload = () => {
              tempCanvas.width = img.width; tempCanvas.height = img.height;
              const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
              tempCtx.fillStyle = bgColor; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); tempCtx.drawImage(img, 0, 0);
              tempCanvas.toBlob(blob => {
                downloadFile(blob, `storyboard-${slug(scene.title || `secuencia-${index+1}`)}.${extension}`);
              }, mimeType, quality);
              URL.revokeObjectURL(img.src);
            };
            img.src = getURLForBlob(scene.sketch);
        }
        
        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 500);
        }

        function cleanupObjectURLCache() {
            const blobsInUse = new Set();
            state.scenes.forEach(scene => {
                if (scene.sketch instanceof Blob) blobsInUse.add(scene.sketch);
                (scene.refs || []).forEach(ref => { if (ref.data instanceof Blob) blobsInUse.add(ref.data); });
            });
            for (const [blob, url] of objectURLCache.entries()) {
                if (!blobsInUse.has(blob)) {
                    URL.revokeObjectURL(url);
                    objectURLCache.delete(blob);
                }
            }
        }
        
        const themeToggle = $('#btn-theme-toggle');
        const themeIcon = $('span', themeToggle);
        const applyTheme = (theme) => {
            const isDark = theme === 'dark';
            document.body.classList.toggle('dark-theme', isDark);
            themeIcon.textContent = isDark ? 'light_mode' : 'dark_mode';
            // Update color pickers to new theme default
            const oldDefault = isDark ? '#000000' : '#ffffff';
            const newDefault = isDark ? '#ffffff' : '#000000';
            $$('.color-picker').forEach(picker => {
                if (picker.value.toLowerCase() === oldDefault) picker.value = newDefault;
            });
        };
        let currentTheme = localStorage.getItem('storyboard-theme') || 'light'; applyTheme(currentTheme);
        themeToggle.onclick = () => { currentTheme = document.body.classList.contains('dark-theme') ? 'light' : 'dark'; localStorage.setItem('storyboard-theme', currentTheme); applyTheme(currentTheme); };
        
        const helpModal = { overlay: $('#help-modal-overlay'), btnOpen: $('#btn-help'), btnClose: $('#help-modal-close') };
        helpModal.btnOpen.onclick = () => { helpModal.overlay.hidden = false; };
        helpModal.btnClose.onclick = () => { helpModal.overlay.hidden = true; };
        helpModal.overlay.onclick = (e) => { if (e.target === helpModal.overlay) helpModal.overlay.hidden = true; };
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !helpModal.overlay.hidden) { helpModal.overlay.hidden = true; } });

        /**************************************************/
        /********** PDF EXPORT IMPLEMENTATION **********/
        /**************************************************/
        async function handleExportPdf() {
            const button = $('#btn-export-pdf');
            if (button.classList.contains('loading')) return;
            button.classList.add('loading'); button.disabled = true;

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const FONT = 'Helvetica';
                const PAGE_WIDTH = doc.internal.pageSize.getWidth();
                const PAGE_HEIGHT = doc.internal.pageSize.getHeight();
                const MARGIN = 15;
                const CONTENT_WIDTH = PAGE_WIDTH - 2 * MARGIN;
                let cursorY = MARGIN;
                const sceneLinks = [];

                const addHeaderFooter = (pageNumber) => {
                    doc.setFont(FONT, 'normal');
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(state.title || 'Proyecto de Escaleta', MARGIN, 10);
                    doc.text(`Página ${pageNumber}`, PAGE_WIDTH - MARGIN, 10, { align: 'right' });
                };

                const checkNewPage = (neededHeight) => {
                    if (cursorY + neededHeight > PAGE_HEIGHT - MARGIN) {
                        doc.addPage();
                        cursorY = MARGIN;
                        addHeaderFooter(doc.internal.getNumberOfPages());
                    }
                };

                const blobToDataURL = (blob) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });

                // 1. Cover Page
                addHeaderFooter(1);
                doc.setFont(FONT, 'bold');
                doc.setFontSize(24);
                doc.text(state.title || 'Proyecto de Escaleta', PAGE_WIDTH / 2, 60, { align: 'center' });
                doc.setFont(FONT, 'normal');
                doc.setFontSize(14);
                if (state.author) doc.text(`Por: ${state.author}`, PAGE_WIDTH / 2, 75, { align: 'center' });
                if (state.synopsis) {
                    doc.setFont(FONT, 'bold'); doc.setFontSize(12);
                    doc.text('Sinopsis', MARGIN, 110);
                    doc.setFont(FONT, 'normal'); doc.setFontSize(10);
                    const synopsisLines = doc.splitTextToSize(state.synopsis, CONTENT_WIDTH);
                    doc.text(synopsisLines, MARGIN, 116);
                }

                // 2. Table of Contents
                doc.addPage();
                cursorY = MARGIN;
                addHeaderFooter(2);
                doc.setFont(FONT, 'bold');
                doc.setFontSize(16);
                doc.text('Índice de Secuencias', MARGIN, cursorY);
                cursorY += 15;
                doc.setFont(FONT, 'normal'); doc.setFontSize(11);
                
                for(const [index, scene] of state.scenes.entries()) {
                    checkNewPage(10);
                    const titleText = `Secuencia ${index + 1}: ${scene.title}`;
                    sceneLinks.push({ page: 0, y: cursorY, text: titleText }); // Store position for later
                    doc.text(titleText, MARGIN, cursorY);
                    cursorY += 8;
                }
                const tocEndPage = doc.internal.getNumberOfPages();

                // 3. Scene details pages
                for (const [index, scene] of state.scenes.entries()) {
                    doc.addPage();
                    cursorY = MARGIN;
                    addHeaderFooter(doc.internal.getNumberOfPages());
                    sceneLinks[index].page = doc.internal.getNumberOfPages();

                    // Scene Header
                    doc.setFillColor(230, 230, 230);
                    doc.rect(MARGIN, cursorY, CONTENT_WIDTH, 10, 'F');
                    doc.setFont(FONT, 'bold'); doc.setFontSize(14);
                    doc.setTextColor(0);
                    doc.text(`SECUENCIA ${index + 1}: ${scene.title}`, MARGIN + 2, cursorY + 7);
                    cursorY += 15;

                    // Location & Tags
                    if (scene.location || (scene.tags && scene.tags.length)) {
                        doc.setFont(FONT, 'bold'); doc.setFontSize(9);
                        if(scene.location) doc.text(`Localización: `, MARGIN, cursorY);
                        doc.setFont(FONT, 'normal');
                        if(scene.location) doc.text(scene.location, MARGIN + 22, cursorY);
                        if (scene.tags && scene.tags.length) {
                           doc.text(`Etiquetas: ${scene.tags.join(', ')}`, CONTENT_WIDTH + MARGIN, cursorY, { align: 'right' });
                        }
                        cursorY += 8;
                    }

                    // Description
                    if (scene.description) {
                        checkNewPage(12);
                        doc.setFont(FONT, 'bold'); doc.setFontSize(11);
                        doc.text('Descripción', MARGIN, cursorY);
                        cursorY += 6;
                        doc.setFont(FONT, 'normal'); doc.setFontSize(10);
                        const descLines = doc.splitTextToSize(scene.description, CONTENT_WIDTH);
                        checkNewPage(descLines.length * 4);
                        doc.text(descLines, MARGIN, cursorY);
                        cursorY += descLines.length * 4 + 5;
                    }
                    
                    // Storyboard
                    if (scene.sketch) {
                        checkNewPage(12 + 80);
                        doc.setFont(FONT, 'bold'); doc.setFontSize(11);
                        doc.text('Storyboard', MARGIN, cursorY);
                        cursorY += 6;
                        const dataUrl = await blobToDataURL(scene.sketch);
                        const imgHeight = (CONTENT_WIDTH * 9) / 16;
                        checkNewPage(imgHeight + 5);
                        doc.addImage(dataUrl, 'PNG', MARGIN, cursorY, CONTENT_WIDTH, imgHeight);
                        cursorY += imgHeight + 10;
                    }

                    // References
                    if (scene.refs && scene.refs.length) {
                        checkNewPage(12);
                        doc.setFont(FONT, 'bold'); doc.setFontSize(11);
                        doc.text('Referencias', MARGIN, cursorY);
                        cursorY += 6;
                        
                        const refWidth = (CONTENT_WIDTH - 10) / 2; // 2 refs per row
                        const refHeight = (refWidth * 9) / 16;
                        let xPos = MARGIN;

                        for (const [refIndex, ref] of scene.refs.entries()) {
                            if (ref.data instanceof Blob) {
                                checkNewPage(refHeight + 10);
                                const dataUrl = await blobToDataURL(ref.data);
                                doc.addImage(dataUrl, 'JPEG', xPos, cursorY, refWidth, refHeight);
                                doc.setFontSize(8); doc.text(ref.name, xPos, cursorY + refHeight + 4);

                                if (refIndex % 2 === 0) {
                                    xPos += refWidth + 10;
                                } else {
                                    xPos = MARGIN;
                                    cursorY += refHeight + 10;
                                }
                            }
                        }
                         if (state.scenes[index].refs.length % 2 !== 0) cursorY += refHeight + 10;
                    }
                }
                
                // 4. Update ToC page links
                for(let i = 1; i <= tocEndPage; i++) {
                    doc.setPage(i);
                    sceneLinks.forEach(link => {
                        if (doc.internal.getCurrentPageInfo().pageNumber === i) {
                            doc.textWithLink('', MARGIN, link.y - 4, { pageNumber: link.page, x: MARGIN, y: MARGIN }); // invisible link area
                        }
                    });
                }

                doc.save(`${slug(state.title || 'proyecto-escaleta')}.pdf`);
            } catch (error) {
                console.error("Error al generar el PDF:", error);
                alert(`Ocurrió un error al generar el PDF: ${error.message}`);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        $('#btn-export-pdf').onclick = handleExportPdf;

        async function exportZip() {
            const button = $('#btn-export-zip');
            if (button.classList.contains('loading')) return;
            button.classList.add('loading'); button.disabled = true;
            try {
                const projectData = await db.project.get(PROJECT_ID);
                if (!projectData) throw new Error("No hay proyecto para exportar.");
                const zip = new JSZip(); const assetsFolder = zip.folder("assets"); const projectJson = JSON.parse(JSON.stringify(projectData));
                for (let i = 0; i < projectData.scenes.length; i++) {
                    const scene = projectData.scenes[i]; const jsonScene = projectJson.scenes[i];
                    if (scene.sketch instanceof Blob) { const filename = `sketch-${scene.id}.png`; assetsFolder.file(filename, scene.sketch); jsonScene.sketch = `assets/${filename}`; }
                    if (scene.refs && scene.refs.length) {
                        for (let j = 0; j < scene.refs.length; j++) {
                            const ref = scene.refs[j];
                            if (ref.data instanceof Blob) {
                                const extension = ref.data.type.split('/')[1] || 'png';
                                const filename = `ref-${scene.id}-${ref.id}.${extension}`;
                                assetsFolder.file(filename, ref.data);
                                projectJson.scenes[i].refs[j].data = `assets/${filename}`;
                            }
                        }
                    }
                }
                zip.file("project.json", JSON.stringify(projectJson, null, 2));
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                downloadFile(zipBlob, `${slug(projectData.title || 'proyecto')}.zip`);
            } catch (error) { console.error("Error al generar el ZIP:", error); alert(`Error al generar ZIP: ${error.message}`);
            } finally { button.classList.remove('loading'); button.disabled = false; }
        }
        $('#btn-export-zip').onclick = exportZip;
        $('#import-zip').onchange = async (e) => {
             const file = e.target.files[0]; if (!file) return;
             try {
                const zip = await JSZip.loadAsync(file);
                const projectFile = zip.file("project.json");
                if (!projectFile) throw new Error("project.json no encontrado en el ZIP.");
                const projectData = JSON.parse(await projectFile.async("string"));
                for (let scene of projectData.scenes) {
                    if (scene.sketch && typeof scene.sketch === 'string') { scene.sketch = await zip.file(scene.sketch).async("blob"); }
                    if (scene.refs) {
                        for (let ref of scene.refs) { if (ref.data && typeof ref.data === 'string') { ref.data = await zip.file(ref.data).async("blob"); } }
                    }
                }
                objectURLCache.forEach(url => URL.revokeObjectURL(url)); objectURLCache.clear();
                delete projectData.id;
                state = projectData;
                await persist(); render();
             } catch(error) { alert("Error al importar el archivo ZIP."); console.error(error); } finally { e.target.value = ''; }
        };
        
        async function resizeImageBeforeSave(blob, maxLongSide = 1200) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                    let { width, height } = img;
                    if (width > height) { if (width > maxLongSide) { height *= maxLongSide / width; width = maxLongSide; } } 
                    else { if (height > maxLongSide) { width *= maxLongSide / height; height = maxLongSide; } }
                    canvas.width = width; canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(resizedBlob => { URL.revokeObjectURL(img.src); resolve(resizedBlob); }, 'image/jpeg', 0.9);
                };
                img.onerror = () => reject(new Error("Could not load image to resize it."));
                img.src = URL.createObjectURL(blob);
            });
        }

        // --- INITIALIZATION ---
        async function initializeApp() {
            const savedState = await db.project.get(PROJECT_ID);
            if (savedState) {
                delete savedState.id;
                Object.assign(state, savedState);
                state.scenes.forEach(s => {
                    if (!s.tags) s.tags = []; if (!s.refs) s.refs = [];
                    if (!s.locationURL) s.locationURL = null; if (!s.statusColor) s.statusColor = null;
                });
            }
            if (!state.scenes.length) { state.scenes.push(defaultScene()); }
            setupEventListeners();
            render();
        }

        initializeApp();
    });
  </script>

  <div id="custom-dialog-overlay" class="dialog-overlay" hidden>
    <div class="dialog-box">
      <h3 id="dialog-title"></h3>
      <p id="dialog-message"></p>
      <div class="dialog-actions">
        <button id="dialog-btn-cancel" class="btn alt">Cancelar</button>
        <button id="dialog-btn-confirm" class="btn primary">Continuar</button>
      </div>
    </div>
  </div>

  <div id="format-dialog-overlay" class="dialog-overlay" hidden>
    <div id="format-dialog-box" class="dialog-box">
      <h3>Seleccionar Formato</h3>
      <p>Elige el formato en el que quieres descargar la imagen del storyboard.</p>
      <div class="dialog-actions">
        <button id="format-btn-png" class="btn alt">PNG (Alta Calidad)</button>
        <button id="format-btn-jpg" class="btn primary">JPEG (Archivo Pequeño)</button>
      </div>
    </div>
  </div>

  <div id="help-modal-overlay" class="help-modal-overlay" hidden>
    <div class="help-modal-box">
      <div class="help-modal-header">
        <h2>Guía Completa de Uso</h2>
        <span class="material-symbols-rounded help-modal-close" id="help-modal-close" title="Cerrar">&times;</span>
      </div>
      <div class="help-modal-content">
        <!-- El contenido del modal de ayuda se puede expandir aquí -->
         <h3>Bienvenido a Escaleta Creator</h3>
        <p>Esta es una guía rápida para ayudarte a sacar el máximo provecho de la herramienta.</p>

        <h4>Información del Proyecto</h4>
        <p>En la parte superior, puedes definir el <strong>Título del proyecto</strong>, el <strong>Autor</strong> y una <strong>Sinopsis</strong> general. Esta información es útil para contextualizar tu trabajo y aparecerá en la exportación a PDF.</p>

        <h4>Gestión de Secuencias</h4>
        <p>El corazón de tu proyecto son las secuencias. Puedes gestionarlas con la barra de herramientas principal y los botones de cada secuencia:</p>
        <ul>
            <li><code>+</code> (Añadir): Crea una nueva secuencia vacía al final de tu proyecto.</li>
            <li><strong>Mover arriba/abajo:</strong> Usa las flechas <span class="material-symbols-rounded" style="vertical-align: sub; font-size: 1em;">arrow_upward</span> / <span class="material-symbols-rounded" style="vertical-align: sub; font-size: 1em;">arrow_downward</span> para reordenar las secuencias.</li>
            <li><strong>Duplicar:</strong> El icono <span class="material-symbols-rounded" style="vertical-align: sub; font-size: 1em;">content_copy</span> crea una copia exacta de la secuencia, incluyendo su contenido.</li>
            <li><strong>Eliminar:</strong> El icono <span class="material-symbols-rounded" style="vertical-align: sub; font-size: 1em;">delete</span> borra la secuencia permanentemente.</li>
            <li><strong>Estado:</strong> Haz clic en el círculo de estado para cambiar su color (Rojo, Naranja, Verde), ideal para marcar el progreso de producción.</li>
        </ul>

        <h4>Pestañas de Contenido</h4>
        <p>Cada secuencia tiene tres pestañas para organizar la información:</p>
        <ol>
            <li><strong>Descripción Escenas:</strong> Aquí va el texto principal de tu escaleta. Describe acciones, diálogos, planos, sonido, etc.</li>
            <li><strong>Referencias:</strong> Sube imágenes de referencia (moodboard, localizaciones, vestuario) para esta secuencia. Puedes cambiarles el nombre y cargarlas en el storyboard.</li>
            <li><strong>Storyboard:</strong> Un lienzo para dibujar tus planos.</li>
        </ol>

        <h4>Herramientas del Storyboard</h4>
        <p>El lienzo de dibujo tiene un completo set de herramientas:</p>
        <ul>
            <li><strong>Herramientas de dibujo:</strong> Pincel, línea, rectángulo, círculo, flecha y texto.</li>
            <li><strong>Grosor y Color:</strong> Ajusta el tamaño y el color de tus herramientas.</li>
            <li><strong>Borrador:</strong> Elimina partes de tu dibujo.</li>
            <li><strong>Añadir a Referencias:</strong> Guarda una copia del storyboard actual como una nueva imagen en la pestaña de Referencias.</li>
            <li><strong>Limpiar:</strong> Borra todo el contenido del lienzo.</li>
        </ul>

        <h4>Exportar e Importar</h4>
        <ul>
            <li><strong>Exportar a PDF:</strong> Genera un documento profesional y bien formateado con toda la información de tu proyecto, listo para compartir.</li>
            <li><strong>Exportar a ZIP:</strong> Crea una copia de seguridad completa de tu proyecto (datos e imágenes) en un archivo <code>.zip</code>. Perfecto para guardarlo o moverlo a otro ordenador.</li>
            <li><strong>Importar desde ZIP:</strong> Carga un proyecto previamente exportado desde un archivo <code>.zip</code> para continuar trabajando.</li>
        </ul>
      </div>
    </div>
  </div>

</body>
</html>
